<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  <subtitle>等自己醒来，重走长征路</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-02-28T11:36:59.303Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨文旭</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>life is a fucking movie.md</title>
    <link href="http://example.com/2021/02/28/life-is-a-fucking-movie/"/>
    <id>http://example.com/2021/02/28/life-is-a-fucking-movie/</id>
    <published>2021-02-28T11:36:47.000Z</published>
    <updated>2021-02-28T11:36:59.303Z</updated>
    
    <content type="html"><![CDATA[<ol><li>人啊，还是多读读书的好，心智可能会更加成熟，遇事更能抗</li><li>相比平庸，我更能接受孤独</li><li>把热爱的事情做成极致，那便成了价值</li><li>给自己两年时间，你会怎样去提高你的水平</li><li>两年后你会是什么样的水平，你能承担多大的责任</li></ol><span id="more"></span><ol><li><p>人啊，还是多读读书的好，心智可能会更加成熟，遇事更能抗</p><p>​       想想自己这几年时间，读的书甚是少，可能相对来说更多的还是一些技术相关的书籍吧。平时空闲的时间可能更多地还是花费在了手机上面，想想以前用腾讯视频看一些动漫看的多，但是从疫情之后，也就不怎么去追动漫了，追的也就秦时明月和斗罗大陆了，如果画江湖的系列更新的话，可能还会再追吧。画江湖系列每一步都从头追到尾了，还记得灵主里面的“今生提着头，还你前世笑”，以前都挺喜欢看的。从疫情之后花费时间最多的可能是抖音了吧。总而言之，手机还是玩的太多了，导致这几年很少去读读书。</p><p>​        技术相关，</p><p>​        技术之外，也不过生活而已。大学的时候重点是看了大冰的书，可能觉得冰叔的那种既能浪迹天涯又能朝九晚五的人生观和自己的差不多吧，所以也一直很欣赏，也能引起自己对于生活的思考。我一直也想在工作忙碌之后，和兄弟们喝喝酒吹吹牛放飞自我，在酒过三巡之后谈谈心说说故事。除此之外，看了一本有关心灵鸡汤方面的书，书名是深夜加油站遇见苏格拉底，总之是说我们不仅在生活和工作上加油，也要经常去给自己的心灵上加一点油，这本书帮助了我很多很多，每次我烦躁不已，焦虑难安的时候我会把这本书拿出来读上一遭。会让我更加自律一点，会让我变得更加平静一点。所以迷茫和焦虑的原因估计就是想的太多，做的又太少，也是因为读的书太少了。所以，人呀，还是多读读书的好，头可能会更加合适一点，心智可能也会更加成熟，可能更会明白生活的意义吧。我们慌慌张张，匆匆忙忙，碎银几两也不全是为了房子和车子，但都是出于对生活的无限热爱与向往，但这种追求自然包含了车子房子。热爱漫无边际，生活自有分寸。虽然说长大了毕业了，男人的快乐越来越少，以前总会说男人的快乐不过就喝酒泡妞打游戏了，后面又说过男人的快乐，不是在梦中，就是在酒中。但心智成熟之后发现，这种对生活的漫无边际的热爱，正是我所追求的快乐吧。</p></li><li><p>相比平庸，我更能接受孤独</p><p>   ​      虽然说早已经习惯一个人自由自在的生活，但可能还是时常会觉得自己稍显孤单一点吧，有时候甚至找不到能和自己一起碰杯饮酒的老友。但自己也很明白，要想更快更好的成长起来，肯定要经历这种深深的孤独吧，强者生而孤独。所以说，相比平庸，我更喜欢孤独吧。已经很长时间很长时间没有谈过女朋友，现在找女朋友肯定和大学里面不一样了，大学里面只是最单纯的仅仅是恋爱而已，对于两个人的未来发展都没有做过考虑。但是现在不一样了，已经也折腾不起了，都已经二十老几的人了，要找就得找确确实实未来会结婚的那种咯。呵，想想自己这一路，跌跌撞撞，兜兜转转，伤害了好多人，辜负了好多人，失去了好多，有太多遗憾，有太多痛苦，但也有太多美好的回忆，只愿我还是我。希望当自己以后找到那个心之所向的女孩时，能把那份最单纯的喜欢和守护，还有数不尽的温柔都给她，也能在谈情说爱时有足够的能力把那一份责任完完全全的抗在肩上。你若敢爱，我必护你一世周全，许你一生所爱。</p></li><li><p>把热爱的事情做成极致，那便成了价值</p><p>​       当你想要开车去周游世界时，并不需要给自己的车装满足够跑完整个世界的油量，<br>而只需要加满第一箱油就可以了，路上有那么多加油站，你随时都可以加油，<br>路上有那么多的人，你也不用所有的事都只靠自己，想要一箱油就跑完整个世界的<br>人遍地都是，但他们可能永远都不会出发，只有那些真正经历过的风景，<br>才会让人真正变得丰富起来，哪怕看风景时的你狼狈不堪。这段话是以前在网上看到，也纯属是鸡汤吧，虽说是鸡汤吧，但人有时候可能确实是需要那么一点来给自己打打气吧。</p><p>​        有过这样一句话“他想把我推向深渊，但他不知道的是，我本就来自于深渊，所以我无所畏惧”，对啊，像我这样一个人飘荡在外，从那时心如死灰之后，就已经在外没有什么彻彻底底在乎的了，也就没有什么害怕的了，所以我这样无所畏惧，也希望能够无坚不摧。所以，以后的路，不要担心什么，只管大胆的去尝试去努力，去把自己热爱的事情做到极致就行了。</p></li><li><p>给自己两年时间，你会怎样去提高你的水平</p><pre><code> 计算机编程知识是需要积累的，花一两年时间啃下那些厚厚的经典书籍后， 才能构建自己的知识体系，然后阅读大量优秀源码，做一些有趣的项目， 编程能力就能突飞猛进啦。 很多技术上的想法，都来自业务本身遇到的问题，挺有意思。</code></pre></li><li><p>两年后你会是什么样的水平，你能承担多大的责任</p><p>   真正好的工作经验应当是持续学习与进步的，<br>   不仅限于技术上的进步，如何写好易于维护的代码、<br>   如何用技术能力保障业务的稳定性、如何引领新人快速融入团队，<br>   都是不可或缺的东西，想要获得这些能力，需要时间，<br>   但更需要你的主动探索与实践，而这些是无法速成的东西，<br>   也是你作为一个技术老鸟，能跟应届生真正拉开差距的地方</p><p>   少年啊，本应该和虎狼一样，那就再努力一点，希望能早日拥有一个人扛事儿的能力。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;人啊，还是多读读书的好，心智可能会更加成熟，遇事更能抗&lt;/li&gt;
&lt;li&gt;相比平庸，我更能接受孤独&lt;/li&gt;
&lt;li&gt;把热爱的事情做成极致，那便成了价值&lt;/li&gt;
&lt;li&gt;给自己两年时间，你会怎样去提高你的水平&lt;/li&gt;
&lt;li&gt;两年后你会是什么样的水平，你能承担多大的责任&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>js基础面试题1</title>
    <link href="http://example.com/2021/02/28/js-base-interview1/"/>
    <id>http://example.com/2021/02/28/js-base-interview1/</id>
    <published>2021-02-28T11:29:52.944Z</published>
    <updated>2020-12-25T00:54:15.191Z</updated>
    
    <content type="html"><![CDATA[<ol><li>数据类型判断</li><li>原型，实例，对象，构造函数，创建对象，继承</li><li>实现new，instanceof，call,  apply, bind</li></ol><span id="more"></span><h2 id="JS中数据类型的判断"><a href="#JS中数据类型的判断" class="headerlink" title="JS中数据类型的判断"></a>JS中数据类型的判断</h2><ol><li><p><strong>typeof</strong> 对于原始类型来说，除了 null 都可以显示正确的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object     []数组的数据类型在 typeof 中被解释为 object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object     null 的数据类型被 typeof 解释为 object</span></span><br></pre></td></tr></table></figure></li></ol><p>  typeof 对于对象来说，除了函数都会显示 object，像数组和对象都是object，所以想判断一个对象的正确类型，这时候需要使用  instanceof</p><ol><li><p><strong>instanceof</strong></p><p>  instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true    </span></span><br><span class="line"><span class="comment">// console.log(undefined instanceof Undefined);</span></span><br><span class="line"><span class="comment">// console.log(null instanceof Null);</span></span><br></pre></td></tr></table></figure></li></ol><p>  instanceof可以精准判断引用数据类型（Array，Function，Object），而基本数据类型不能被instanceof精准判断。</p><pre><code>instanceof 在MDN中的解释：instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</code></pre><ol><li><strong>constructor</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line">这里有一个坑，如果我创建一个对象，更改它的原型，<span class="title">constructor</span>就会变得不可靠了</span><br><span class="line"><span class="title">function</span> <span class="title">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true </span></span><br></pre></td></tr></table></figure><ol><li><strong>Object.prototype.toString.call()</strong> 使用 Object 对象的原型方法 toString ，使用 call 进行狸猫换太子，借用Object的 toString 方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure><h2 id="原型-实例-对象-构造函数"><a href="#原型-实例-对象-构造函数" class="headerlink" title="原型,实例,对象,构造函数"></a>原型,实例,对象,构造函数</h2><p>​    <img src="http://yangwenxu.cn/assets/images/prototype.png" alt="prototype" style="zoom: 67%;" /></p><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">getName</span>: <span class="title">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;james&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;devin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// devin</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age); <span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="string">&#x27;young&#x27;</span>, <span class="string">&#x27;20&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// daisy</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors); <span class="comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手写实现new"><a href="#手写实现new" class="headerlink" title="手写实现new"></a>手写实现new</h2><ol><li><p>创建一个简单的空对象</p></li><li><p>链接该对象（即设置该对象的构造函数）到另一个对象 ；</p></li><li><p>将创建的新的对象作为this的上下文</p></li><li><p>如果该函数没有返回对象则返回this， 如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  <span class="keyword">let</span> con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  obj.__proto__ = con.prototype;</span><br><span class="line">  con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.color + <span class="string">&quot;zhaobuchu&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = create(Car, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(car.color);</span><br><span class="line"><span class="built_in">console</span>.log(car.start());</span><br></pre></td></tr></table></figure><ul><li><p>```javaScript</p><p>function create() {<br>  Con = [].shift.call(arguments);<br>  var obj = Object.create(Con.prototype);<br>  var ret = Con.apply(obj,arguments);<br>  return ret instanceof Object ? ret : obj;<br>}</p><p>function Car(color, name) {<br>  this.color = color;<br>  return {</p><pre><code>name: name</code></pre><p>  }<br>}<br>var car = create(Car, “blue”, “宝马”)<br>console.log(car.color);<br>console.log(car.name)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 手写实现instanceOf</span><br><span class="line"></span><br><span class="line">  instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class="line"></span><br><span class="line">  实现 instanceof：</span><br><span class="line"></span><br><span class="line">1. 首先获取类型的原型</span><br><span class="line">2. 然后获得对象的原型</span><br><span class="line">3. 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;javaScript</span><br><span class="line"></span><br><span class="line">function instanceOf(left, right)&#123;</span><br><span class="line">  let proto &#x3D; left._proto_;</span><br><span class="line">  let prototype &#x3D; right.prototype;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if(proto &#x3D;&#x3D;&#x3D; null)</span><br><span class="line">      return false;</span><br><span class="line">    if(proto &#x3D;&#x3D;&#x3D; prototype) </span><br><span class="line">      return true;</span><br><span class="line">    proto &#x3D; proto._proto_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="手写实现call"><a href="#手写实现call" class="headerlink" title="手写实现call"></a>手写实现call</h2><ol><li>用this获取这个函数并设置为对象的属性</li><li>执行这个函数</li><li>删除这个函数</li><li>指定this到函数并传入给定参数执行函数,如果不传入参数，默认指向为 window</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  context.fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="string">&#x27;zhaobuchu&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call2(foo, <span class="string">&#x27;yangwenxu&#x27;</span>, <span class="number">22</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手写实现apply"><a href="#手写实现apply" class="headerlink" title="手写实现apply"></a>手写实现apply</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  value: <span class="string">&quot;zhaobuchu&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.apply2(obj, [<span class="string">&quot;yangwenxu&quot;</span>, <span class="number">22</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手写实现bind"><a href="#手写实现bind" class="headerlink" title="手写实现bind"></a>手写实现bind</h2><ol><li>使用 call / apply 指定 this 。</li><li>使用 return 返回一个函数。</li><li>使用 arguments 获取参数数组并作为 self.apply() 的第二个参数。</li><li>获取返回函数的参数，然后同第3点的参数合并成一个参数数组，并作为 self.apply() 的第二个参数.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="string">&quot;zhaobuchu&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value: <span class="built_in">this</span>.value,</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind2(foo, <span class="string">&quot;james&quot;</span>);</span><br><span class="line">bindFoo(<span class="number">22</span>);</span><br></pre></td></tr></table></figure><p>一个绑定函数也能使用new操作符创建对象：<br>这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 注释1</span></span><br><span class="line">      <span class="keyword">return</span> self.apply(</span><br><span class="line">          <span class="built_in">this</span> <span class="keyword">instanceof</span> fBound ? <span class="built_in">this</span> : context, </span><br><span class="line">          args.concat(bindArgs)</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注释2</span></span><br><span class="line">  fBound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="string">&quot;zhaobuchu&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">bar.prototype.friend = <span class="string">&#x27;kevin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind2(foo, <span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bindFoo(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.habit);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.friend);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>bind实现需要考虑实例化后对原型链的影响。<br>用一个空对象作为中介，把 fBound.prototype 赋值为空对象的实例（原型式继承）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;数据类型判断&lt;/li&gt;
&lt;li&gt;原型，实例，对象，构造函数，创建对象，继承&lt;/li&gt;
&lt;li&gt;实现new，instanceof，call,  apply, bind&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>css-base-interview</title>
    <link href="http://example.com/2021/02/28/css-base-interview/"/>
    <id>http://example.com/2021/02/28/css-base-interview/</id>
    <published>2021-02-28T11:29:52.942Z</published>
    <updated>2020-12-25T00:54:15.187Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>基础：position，盒子模型，display，BFC，清除浮动，选择器，层叠上下文</p></li><li><p>水平垂直居中，三栏布局，<strong>flex布局</strong></p></li></ol><span id="more"></span><h2 id="1-position"><a href="#1-position" class="headerlink" title="1. position"></a>1. position</h2><p> <strong>static</strong> : 默认</p><p><strong>relative相对定位</strong>:<br>    不脱离文档流，元素相对于自身 content box 定位，仍占据原来位置空间； </p><p><strong>absolute绝对定位</strong>:<br>    脱离文档流，元素相对于第一个 position 不为 static 的祖先元素的 padding box 定位，元素不占据原来位置空间；</p><p> <strong>fixed固定定位</strong>:<br>    脱离文档流，元素相对于浏览器窗口顶部定位，不占据原来位置空间。</p><p> <strong>sticky粘性定位</strong>:<br>    必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。<br>    设定为 position:sticky 元素的任意父节点的 overflow 属性必须是 visible</p><h2 id="2-css盒子模型"><a href="#2-css盒子模型" class="headerlink" title="2. css盒子模型"></a>2. css盒子模型</h2><p>css 中，盒模型分为 content、padding、border、margin四部分，又有两种盒模型，通过 box-sizing 切换：</p><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p>当设置为 content-box 时，属于标准盒模型，在设置宽度和高度时，只包含 content，不包含 padding 和 border；</p><h3 id="IE盒模型-怪异模型"><a href="#IE盒模型-怪异模型" class="headerlink" title="IE盒模型(怪异模型)"></a>IE盒模型(怪异模型)</h3><p>而设为 border-box 时，属于 IE 盒模型，设置宽度和高度时，包含 content、padding 和 border。</p><h2 id="3-水平垂直居中"><a href="#3-水平垂直居中" class="headerlink" title="3. 水平垂直居中"></a>3. 水平垂直居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li>行内元素：<code>text-align:center</code></li><li>已知元素的宽度： 设置margin:0 auto</li><li>元素的宽度不确定:<ul><li>flex 布局 justify-content:center</li><li>设置为inline/inline-block布局，然后用text-align:center</li><li>绝对定位，使用transform:translateX(-width/2)或margin-left:-width/2</li></ul></li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li><p>行内元素：<code>line-height:height</code>或者给父元素设置<code>display:table-cell vertical-align:middle</code></p></li><li><p>使用定位: 垂直方向移动50%的距离，然后使用margin-top或者tanslateY(-50%)</p></li><li><p>flex布局: aligin-items:center</p></li></ol><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><ul><li><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="transform-css3属性"><a href="#transform-css3属性" class="headerlink" title="transform(css3属性)"></a>transform(css3属性)</h4></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="margin负值"><a href="#margin负值" class="headerlink" title="margin负值"></a>margin负值</h4></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">75px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h4 id="absolute和margin"><a href="#absolute和margin" class="headerlink" title="absolute和margin"></a>absolute和margin</h4></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent-absolute-margin</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">800px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child-absolute-margin</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-Flex布局"><a href="#4-Flex布局" class="headerlink" title="4. Flex布局"></a>4. Flex布局</h2><h3 id="flex布局概念"><a href="#flex布局概念" class="headerlink" title="flex布局概念:"></a>flex布局概念:</h3><p>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><h3 id="flex的结构组成"><a href="#flex的结构组成" class="headerlink" title="flex的结构组成:"></a>flex的结构组成:</h3><p>Flex布局有两层,采用flex布局的元素称为flex容器,其子元素则自动成flex item,即项目.</p><ol><li>Flex container</li><li>Flex Item</li></ol><h3 id="常用的Flex属性"><a href="#常用的Flex属性" class="headerlink" title="常用的Flex属性:"></a>常用的Flex属性:</h3><p>Flex容器container:</p><ol><li>flex容器有两根轴:水平主轴就是x轴(main axis)和竖直轴也是y轴(cross axis)</li><li><p>flex容器属性:</p><ul><li>flex-direction:决定项目的排列方向。</li><li>flex-wrap:即一条轴线排不下时如何换行。</li><li>flex-flow:是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content:定义了项目在主轴上的对齐方式。(justify)</li><li>align-items:定义项目在交叉轴上如何对齐。</li><li>align-content:定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。(换        行会产生多轴)</li></ul></li><li><p>Flex item属性:</p><ul><li>order:定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow:定义项目的放大比例,如果所有项目的flex-grow属性都为1，则它们将等分剩余空间        （如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空        间将比其他项多一倍。</li><li>flex-shrink:定义了项目的缩小比例，默认为1，如果所有项目的flex-shrink属性都为1，当空        间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空            间不足时，前者不缩小。</li><li>flex-basis:定义了在分配多余空间之前，项目占据的主轴空间（main size）。</li><li>flex:是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</li><li>align-self:允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为              auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul></li></ol><h3 id="常用的布局"><a href="#常用的布局" class="headerlink" title="常用的布局"></a>常用的布局</h3><ol><li>左右两列</li><li>上下两列</li></ol><h2 id="5-css的选择器"><a href="#5-css的选择器" class="headerlink" title="5. css的选择器"></a>5. css的选择器</h2><h3 id="选择器的解析"><a href="#选择器的解析" class="headerlink" title="选择器的解析"></a>选择器的解析</h3><p>样式系统从关键选择器开始，向左依次查找规则选择器的祖先元素，如果出现未匹配的情况会放弃规则，否则会左移直至匹配完成。因此在写样式时，应尽量选择 ID 选择器或 class 选择器作为关键选择器，并且减少样式的层级，降低消耗。</p><h3 id="选择的优先级"><a href="#选择的优先级" class="headerlink" title="选择的优先级"></a>选择的优先级</h3><ol><li>@important 权重最高</li><li>行内样式权重为 1000</li><li>ID 选择器权重为 0100</li><li>类选择器，伪类选择器，属性选择器权重为 0010</li><li>元素选择器和伪元素选择器权重为 0001</li><li>通配符 &gt; 继承 &gt; 浏览器默认</li></ol><h2 id="6-高度塌陷，清除浮动"><a href="#6-高度塌陷，清除浮动" class="headerlink" title="6. 高度塌陷，清除浮动"></a>6. 高度塌陷，清除浮动</h2><h3 id="高度塌陷产生的原因"><a href="#高度塌陷产生的原因" class="headerlink" title="高度塌陷产生的原因"></a>高度塌陷产生的原因</h3><p>   当父元素不给高度的时候，内部元素不浮动时会撑开, 而浮动的时候，父元素变成一条线, 造成塌陷.</p><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ol><li><p>额外标签法：在最后一个浮动标签后，新加一个标签，给其设置clear：both；</p></li><li><p>触发BFC: 给父元素添加overflow:hidden;</p><p>overflow: hidden能清除块内子元素的浮动影响. </p><p>因为该属性进行超出隐藏时需要计算盒子内所有元素的高度, 所以会隐式清除浮动</p></li><li><p>使用after伪元素清除浮动</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table; // <span class="attribute">clear</span> 属性在块级元素下才能起作用</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: <span class="number">1</span>; // IE6+ 兼容</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用before和after双伪元素清除浮动</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-BFC块级格式化上下文"><a href="#7-BFC块级格式化上下文" class="headerlink" title="7. BFC块级格式化上下文"></a>7. BFC块级格式化上下文</h2></li><li><p>BFC 指的是格式化上下文，当一个元素形成 BFC 后，内部元素和外部元素相互隔离，然后内部元素和外部元素不会相互影响。</p></li><li><p>一般根元素、浮动元素、绝对定位元素、行内块元素、表格类元素、还有 overflow 不为 visible 的元素都会创建 BFC。</p></li><li><p>应用：</p><ul><li><p>阻止<code>margin</code>重叠，</p></li><li><p>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 BFC 区域之中)，</p></li><li><p>自适应两栏布局</p></li><li><p>可以阻止元素被浮动元素覆盖</p></li></ul></li></ol><h2 id="8-三栏布局"><a href="#8-三栏布局" class="headerlink" title="8. 三栏布局"></a>8. 三栏布局</h2><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>左右两栏浮动（脱离文档流），中间一栏通过 margin 左右值（左右两栏的宽度以及栏外间距), 注意要清除浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.three-column-float</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.float-left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: deepskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.float-right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.float-center</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">320px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>左右两栏绝对定位（脱离文档流），中间一栏通过 margin 左右值（左右两栏的宽度以及栏外间距）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.three-column-absolute</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.absolute-left</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:deepskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.absolute-right</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.absolute-center</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">320px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-px-rem-em-vh-vw这些单位的区别"><a href="#9-px-rem-em-vh-vw这些单位的区别" class="headerlink" title="9. px rem em vh.vw这些单位的区别"></a>9. px rem em vh.vw这些单位的区别</h2><ol><li><p>px 像素，对于普通的屏幕，就是代表一个像素点。 </p></li><li><p>rem，是相对于根元素的font-size来决定的，可以由用户自己设定 </p></li><li><p>em 是根据元素的font-size大小来决定的 </p></li><li><p>vh 是当前视口高度的占比（视口就是当前肉眼可见的区域） ，1vh等于视窗高度的1%。</p></li><li><p>vw 是当前视口宽度的占比，1vw等于视窗宽度的1%。</p></li></ol><h2 id="10-层叠上下文，z-index"><a href="#10-层叠上下文，z-index" class="headerlink" title="10. 层叠上下文，z-index"></a>10. 层叠上下文，z-index</h2><ol><li>层叠上下文： 三维z轴上的层叠关系</li><li>产生： 普通元素设置<code>position</code>属性为非<code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文</li><li>层叠等级：z-index&gt;0  z-index:auto/z-index:0  inline-block float block  z-index&lt;0</li></ol><h2 id="11-display详解"><a href="#11-display详解" class="headerlink" title="11. display详解"></a>11. display详解</h2><ol><li><p>行内元素和块状元素</p><p>块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度</p><p>行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。</p></li><li><p>display：none和visibility=hidden, opacity=0的区别</p><p>opacity=0：该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的</p><p>visibility=hidden：该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</p><p>display=none：把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p></li></ol><h2 id="12-移动端适配"><a href="#12-移动端适配" class="headerlink" title="12. 移动端适配"></a>12. 移动端适配</h2><h2 id="13-background的background-image-和-background-color-属性"><a href="#13-background的background-image-和-background-color-属性" class="headerlink" title="13. background的background-image 和 background-color 属性"></a>13. background的<code>background-image</code> 和 <code>background-color</code> 属性</h2><ol><li>CSS 中的 <code>background</code> 的 <code>background-image</code> 属性可以和 <code>background-color</code> 属性一起生效么？</li><li>background-color<code>属性可以覆盖</code>background-image` 属性吗？</li></ol><h2 id="14-预处理语言sass和less"><a href="#14-预处理语言sass和less" class="headerlink" title="14. 预处理语言sass和less"></a>14. 预处理语言sass和less</h2>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基础：position，盒子模型，display，BFC，清除浮动，选择器，层叠上下文&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;水平垂直居中，三栏布局，&lt;strong&gt;flex布局&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>字节前端面经</title>
    <link href="http://example.com/2021/02/28/%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/"/>
    <id>http://example.com/2021/02/28/%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-02-28T11:29:52.940Z</published>
    <updated>2020-12-25T00:54:15.225Z</updated>
    
    <content type="html"><![CDATA[<ol><li>体验极佳，只不过有点可惜，</li><li>最后两道简单的编程题写的不好，最后一道算法时间复杂度太高了。</li><li>应该是编程题没写好，导致没有三面了。除了可惜就是可惜</li><li>以后的路得更加努力，我还年轻，吃苦趁现在。</li></ol><span id="more"></span><h2 id="一面面经："><a href="#一面面经：" class="headerlink" title="一面面经："></a>一面面经：</h2><h3 id="1-浏览器垃圾回收机制"><a href="#1-浏览器垃圾回收机制" class="headerlink" title="1. 浏览器垃圾回收机制"></a>1. 浏览器垃圾回收机制</h3><h3 id="2-for-in和for-of的区别"><a href="#2-for-in和for-of的区别" class="headerlink" title="2. for in和for of的区别"></a>2. for in和for of的区别</h3><h3 id="3-vue检测数组的变化"><a href="#3-vue检测数组的变化" class="headerlink" title="3. vue检测数组的变化"></a>3. vue检测数组的变化</h3><h3 id="4-nextTick的原理"><a href="#4-nextTick的原理" class="headerlink" title="4. nextTick的原理"></a>4. nextTick的原理</h3><h3 id="5-useEffect和userLayoutEffect的区别"><a href="#5-useEffect和userLayoutEffect的区别" class="headerlink" title="5. useEffect和userLayoutEffect的区别"></a>5. useEffect和userLayoutEffect的区别</h3><h3 id="6-node相关"><a href="#6-node相关" class="headerlink" title="6. node相关"></a>6. node相关</h3><h3 id="7-数据库相关"><a href="#7-数据库相关" class="headerlink" title="7. 数据库相关"></a>7. 数据库相关</h3><h3 id="8-http头部"><a href="#8-http头部" class="headerlink" title="8. http头部"></a>8. http头部</h3><h3 id="9-http和https的区别"><a href="#9-http和https的区别" class="headerlink" title="9. http和https的区别"></a>9. http和https的区别</h3><h3 id="10-web网络安全"><a href="#10-web网络安全" class="headerlink" title="10. web网络安全"></a>10. web网络安全</h3><h3 id="11-抛硬币问题"><a href="#11-抛硬币问题" class="headerlink" title="11. 抛硬币问题"></a>11. 抛硬币问题</h3><h3 id="12-函数柯里化-编程题"><a href="#12-函数柯里化-编程题" class="headerlink" title="12. 函数柯里化(编程题)"></a>12. 函数柯里化(编程题)</h3><h3 id="13-类防抖节流编程题"><a href="#13-类防抖节流编程题" class="headerlink" title="13. 类防抖节流编程题"></a>13. 类防抖节流编程题</h3><pre><code>实现一个repeat方法，要求如下：// 需要实现的函数 function repeat (func, times, wait) &#123;&#125;， // 使下面调用代码能正常工作 const repeatFunc = repeat(console.log, 4, 3000);repeatFunc(&quot;hellworld&quot;);//会输出4次 helloworld, 每次间隔3秒</code></pre><h2 id="二面面经："><a href="#二面面经：" class="headerlink" title="二面面经："></a>二面面经：</h2><h3 id="1-项目相关"><a href="#1-项目相关" class="headerlink" title="1. 项目相关"></a>1. 项目相关</h3><h3 id="2-http状态码"><a href="#2-http状态码" class="headerlink" title="2. http状态码"></a>2. http状态码</h3><h3 id="3-tcp和udp的区别"><a href="#3-tcp和udp的区别" class="headerlink" title="3. tcp和udp的区别"></a>3. tcp和udp的区别</h3><h3 id="4-http里面的算法"><a href="#4-http里面的算法" class="headerlink" title="4. http里面的算法"></a>4. http里面的算法</h3><h3 id="5-iframe的缺点"><a href="#5-iframe的缺点" class="headerlink" title="5. iframe的缺点"></a>5. iframe的缺点</h3><p>​        1，会阻塞主页面的onload事件</p><p>​        2，即使iframe的内容为空，加载也需要时间</p><p>​        3，该元素没有语义，不利于seo</p><p>​        4，iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。</p><h3 id="6-跨域及解决办法"><a href="#6-跨域及解决办法" class="headerlink" title="6. 跨域及解决办法"></a>6. 跨域及解决办法</h3><h3 id="7-webpack性能优化"><a href="#7-webpack性能优化" class="headerlink" title="7. webpack性能优化"></a>7. webpack性能优化</h3><h3 id="8-call，apply，bind的区别"><a href="#8-call，apply，bind的区别" class="headerlink" title="8. call，apply，bind的区别"></a>8. call，apply，bind的区别</h3><h3 id="9-promise异步写答案"><a href="#9-promise异步写答案" class="headerlink" title="9. promise异步写答案"></a>9. promise异步写答案</h3><ul><li>```js<br>setTimeout(function() {<br>   console.log(1)<br>}, 0);<br>new Promise(function(resolve) {<br>   console.log(2);<br>   for(var i=0 ; i &lt; 10000 ; i++) {<pre><code> if (i == 9999) &#123;    resolve(); &#125;</code></pre>   }<br>   console.log(3);<br>}).then(function() {<br>   console.log(4);<br>});<br>console.log(5);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">### 10. this指向写答案</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  var length &#x3D; 10;</span><br><span class="line">  function fn() &#123;</span><br><span class="line">    return this.length+1;</span><br><span class="line">  &#125;</span><br><span class="line">  var obj &#x3D; &#123;</span><br><span class="line">     length: 5,</span><br><span class="line">     test1: function() &#123;</span><br><span class="line">        return fn();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.test2&#x3D;fn;</span><br><span class="line">  &#x2F;&#x2F;下面代码输出是什么</span><br><span class="line">  console.log(obj.test1())</span><br><span class="line">  console.log(fn()&#x3D;&#x3D;&#x3D;obj.test2())</span><br></pre></td></tr></table></figure></li></ul><h3 id="11-Node-js读取文件"><a href="#11-Node-js读取文件" class="headerlink" title="11. Node.js读取文件"></a>11. Node.js读取文件</h3><h3 id="12-算法编程题"><a href="#12-算法编程题" class="headerlink" title="12. 算法编程题"></a>12. 算法编程题</h3><p>​    500张骨牌整齐地排成一行，按顺序编号为1、2、3、……、499、500。第一次拿走所有奇数位置上的骨牌，第二次再从剩余骨牌      中拿走奇数位置上的骨牌，以此类推。请问最后剩下的一张骨牌的编号是？</p><h3 id="13-算法编程题"><a href="#13-算法编程题" class="headerlink" title="13. 算法编程题"></a>13. 算法编程题</h3><p>​    三数之和：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在三个元素 a，b，c  ，使得 a + b + c的值与target相等？</p>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;体验极佳，只不过有点可惜，&lt;/li&gt;
&lt;li&gt;最后两道简单的编程题写的不好，最后一道算法时间复杂度太高了。&lt;/li&gt;
&lt;li&gt;应该是编程题没写好，导致没有三面了。除了可惜就是可惜&lt;/li&gt;
&lt;li&gt;以后的路得更加努力，我还年轻，吃苦趁现在。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="front-end" scheme="http://example.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="http://example.com/2021/02/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/02/28/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-28T11:29:52.938Z</published>
    <updated>2020-12-25T00:54:15.223Z</updated>
    
    <content type="html"><![CDATA[<ol><li>代码执行更快</li><li>文件加载更快，首屏加载优化</li><li>webpack性能优化</li></ol><span id="more"></span><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。<br>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等<br>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。<br>请求带宽：压缩文件，开启GZIP，</p><h2 id="编码优化"><a href="#编码优化" class="headerlink" title="编码优化"></a>编码优化</h2><h3 id="html-优化"><a href="#html-优化" class="headerlink" title="html 优化:"></a>html 优化:</h3><ul><li>减少 dom 数量，避免不必要的节点或嵌套；</li></ul><h3 id="css-优化"><a href="#css-优化" class="headerlink" title="css 优化:"></a>css 优化:</h3><ul><li>使用 <code>&lt;link&gt;</code> 替代原生 @import；</li><li>特定的选择器 好过一层一层查找:  .xxx-child-text{} 优于 .xxx .child .text{}</li><li>减少使用通配符与属性选择器；</li><li>层级扁平，避免过于多层级的选择器嵌套；</li><li>减少不必要的多余属性；</li><li>使用 动画属性 实现动画，动画时脱离文档流，开启硬件加速，优先使用 css 动画；</li></ul><h3 id="dom-优化"><a href="#dom-优化" class="headerlink" title="dom 优化:"></a>dom 优化:</h3><ul><li><p>减少访问 dom 的次数，如需多次，将 dom 缓存于变量中；</p></li><li><p>减少重绘与回流</p></li><li><p>使用事件委托，避免大量的事件绑定；</p></li></ul><h3 id="JavaScript代码优化"><a href="#JavaScript代码优化" class="headerlink" title="JavaScript代码优化"></a>JavaScript代码优化</h3><ol><li><p><strong>数据读取:</strong></p><ul><li>通过作用域链 / 原型链 读取变量或方法时，需要更多的耗时，且越长越慢；</li><li>对象嵌套越深，读取值也越慢；</li></ul></li></ol><ul><li>尽量在局部作用域中进行变量缓存；</li><li>避免嵌套过深的数据结构，数据扁平化 有利于数据的读取和维护；</li></ul><ol><li><strong>循环</strong>: 降低算法时间复杂度</li><li><strong>条件流程性能</strong>: Map / Object &gt; switch &gt; if-else</li></ol><h3 id="浏览器网络优化"><a href="#浏览器网络优化" class="headerlink" title="浏览器网络优化"></a>浏览器网络优化</h3><ul><li><strong>减少 cookie 体积</strong>: 能有效减少每次请求的体积和响应时间；<ul><li>去除不必要的 cookie；</li><li>压缩 cookie 大小；</li><li>设置 domain 与 过期时间；</li></ul></li></ul><h2 id="文件加载优化"><a href="#文件加载优化" class="headerlink" title="文件加载优化"></a>文件加载优化</h2><h3 id="引入位置"><a href="#引入位置" class="headerlink" title="引入位置:"></a>引入位置:</h3><p>​    css 文件<code>&lt;head&gt;</code>中引入， js 文件<code>&lt;body&gt;</code>底部引入；</p><p>​    影响首屏的，优先级很高的 js 也可以头部引入，甚至内联；</p><h3 id="减少请求-http-1-0-1-1-："><a href="#减少请求-http-1-0-1-1-：" class="headerlink" title="减少请求 (http 1.0 - 1.1)："></a>减少请求 (http 1.0 - 1.1)：</h3><p>​    合并请求，正确设置 http 缓存；</p><h3 id="减少文件体积"><a href="#减少文件体积" class="headerlink" title="减少文件体积:"></a>减少文件体积:</h3><ul><li>删除多余代码 :<ul><li>tree-shaking</li><li>UglifyJs</li><li>code-spliting</li></ul></li><li>混淆 / 压缩代码，开启 gzip 压缩；</li><li><p>多份编译文件按条件引入 :</p><ul><li>针对现代浏览器直接给 ES6 文件，只针对低端浏览器引用编译后的 ES5 文件；</li><li>可以利用<code>&lt;script type=&quot;module&quot;&gt; / &lt;script type=&quot;module&quot;&gt;</code>进行条件引入用</li></ul></li><li><p>动态 polyfill，只针对不支持的浏览器引入 polyfill；</p></li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化:"></a>图片优化:</h3><ul><li>小图片合成 雪碧图，低于 5K 的图片可以转换成 base64 内嵌；</li><li>合适场景下，使用 iconfont 或者 svg；</li></ul><h3 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存:"></a>使用缓存:</h3><ul><li><p>浏览器缓存: 通过设置请求的过期时间，合理运用浏览器缓存；</p></li><li><p>CDN缓存: 静态文件合理使用 CDN 缓存技术；</p><ul><li>HTML 放于自己的服务器上；</li></ul></li><li><p>打包后的图片 / js / css 等资源上传到 CDN 上，文件带上 hash 值；</p><ul><li>由于浏览器对单个域名请求的限制，可以将资源放在多个不同域的 CDN 上，可以绕开该限制；</li></ul></li><li><p>服务器缓存: 将不变的数据、页面缓存到 内存 或 远程存储(redis等) 上；</p></li><li><p>数据缓存: 通过各种存储将不常变的数据进行缓存，缩短数据的获取时间；</p></li></ul><h2 id="webpack性能优化"><a href="#webpack性能优化" class="headerlink" title="webpack性能优化"></a>webpack性能优化</h2><h3 id="webpack原理："><a href="#webpack原理：" class="headerlink" title="webpack原理："></a><strong>webpack原理</strong>：</h3><p>​    通过分析模块之间的依赖，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。最终将所有模块打包成一份或者多份代码包 (bundler)。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制。loader基于node的环境，拥有比较高的权限。loader对 Webpack 传入的字符串进行按需修改，通常是需要将代码进行分析，构建 AST (抽象语法树)， 遍历进行定向的修改后，再重新生成新的代码字符串。Webpack 会按顺序链式调用每个 Loader，每个loader也只做一件事，输入与输出均为字符串，各个 Loader 完全独立，即插即用。</p><h3 id="常用-Loader"><a href="#常用-Loader" class="headerlink" title="常用 Loader:"></a><strong>常用 Loader</strong>:</h3><ul><li>file-loader: 加载文件资源，如 字体 / 图片 等，具有移动/复制/命名等功能；</li><li>url-loader: 通常用于加载图片，可以将小图片直接转换为 Date Url，减少请求；</li><li>babel-loader: 加载 js / jsx 文件， 将 ES6 / ES7 代码转换成 ES5，抹平兼容性问题；</li><li>ts-loader: 加载 ts / tsx 文件，编译 TypeScript；</li><li>style-loader: 将 css 代码以<code>&lt;style&gt;</code>标签的形式插入到 html 中；</li><li>css-loader: 分析<code>@import</code>和<code>url()</code>，引用 css 文件与对应的资源；</li><li>less-loader / sass-loader: css预处理器，在 css 中新增了许多语法，提高了开发效率；</li></ul><h3 id="常用-Plugin"><a href="#常用-Plugin" class="headerlink" title="常用 Plugin:"></a><strong>常用 Plugin</strong>:</h3><ul><li><p>UglifyJsPlugin: 压缩、混淆代码；</p></li><li><p>CommonsChunkPlugin: 代码分割；</p></li><li><p>ProvidePlugin: 自动加载模块；</p></li><li><p>html-webpack-plugin: 加载 html 文件，并引入 css / js 文件；</p></li><li><p>extract-text-webpack-plugin / mini-css-extract-plugin: 抽离样式，生成 css 文件；</p></li><li><p>DefinePlugin: 定义全局变量；</p></li><li><p>optimize-css-assets-webpack-plugin: CSS 代码去重；</p></li><li><p>webpack-bundle-analyzer: 代码分析；</p></li><li><p>compression-webpack-plugin: 使用 gzip 压缩 js 和 css；</p></li><li><p>happypack: 使用多进程，加速代码构建；</p></li><li><p>EnvironmentPlugin: 定义环境变量</p></li></ul><h3 id="Loader和Plugin的不同"><a href="#Loader和Plugin的不同" class="headerlink" title="Loader和Plugin的不同"></a><strong>Loader和Plugin的不同</strong></h3><ol><li><p><strong>不同的作用</strong></p><ul><li><strong>Loader</strong>直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</li><li><strong>Plugin</strong>直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul></li><li><p><strong>不同的用法</strong></p><ul><li><p><strong>Loader</strong>在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</p></li><li><p><strong>Plugin</strong>在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传</p></li></ul></li></ol><h3 id="webpack打包的文件名为啥是-hash-js的方式"><a href="#webpack打包的文件名为啥是-hash-js的方式" class="headerlink" title="webpack打包的文件名为啥是_hash.js的方式:"></a>webpack打包的文件名为啥是_hash.js的方式:</h3><ol><li>文件名？_h=hash 的方式和上面的区别是啥，</li><li>静态资源在cdn上，先部署模板html，还是先部署静态资源</li></ol><h3 id="webpack性能优化-1"><a href="#webpack性能优化-1" class="headerlink" title="webpack性能优化"></a>webpack性能优化</h3><h4 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h4><p>   在一些性能开销较大的 <code>loader</code> 之前添加 <code>cache-loader</code>，将<code>loader</code> 的编译结果缓存中磁盘中。再次构建如果文件没有发生变化则会  直接拉取缓存。如果只给 <code>babel-loader</code> 配置 <code>cache</code> 的话，也可以不使用cache-loader，给 babel-loader增加选项 <code>cacheDirectory</code>。</p><p> 通过<code>uglifyjs-webpack-plugin</code>这个插件也可以解决缓存问题。</p><p> 缓存的原理就是更快读写的存储介质+减少IO+减少CPU计算=性能优化。而性能优化的第一定律就是：优先考虑使用缓存。</p><p> 缓存的主要手段有：浏览器缓存、CDN、反向代理、本地缓存、分布式缓存、数据库缓存。</p><h4 id="2-摇树优化-Tree-shaking-，"><a href="#2-摇树优化-Tree-shaking-，" class="headerlink" title="2. 摇树优化 (Tree-shaking)，"></a>2. 摇树优化 (Tree-shaking)，</h4><p>  通过 ES6 的 <code>import/export</code> 来检查未引用代码，以及 <code>sideEffects</code> 来标记无副作用代码，最后用 <code>UglifyJSPlugin</code> 来做 <code>Tree Shaking</code>，从而删除冗余代码。但是具有副作用的函数无法被 tree-shaking</p><h4 id="3-code-spliting-代码分割-，按需加载"><a href="#3-code-spliting-代码分割-，按需加载" class="headerlink" title="3. code-spliting:代码分割 ，按需加载"></a>3. code-spliting:代码分割 ，按需加载</h4><p>   代码分割是指：将脚本中无需立即调用的代码在代码构建时转变为异步加载的过程。</p><p>  在 Webpack 构建时，会避免加载已声明要异步加载的代码，异步代码在 Webpack 中使用 SplitChunksPlugin 拆分出一个文件，。当代 码实际调用时被加载至页面。</p><p>  代码分割技术的核心是 <strong>异步加载资源</strong>。</p><p>  在 Vue 中，可以直接使用 <code>import()</code> 关键字做到这一点，而在 React 中，需要使用 <code>react-loadable</code> 去完成同样的事。</p><h4 id="4-静态资源分离"><a href="#4-静态资源分离" class="headerlink" title="4. 静态资源分离"></a>4. 静态资源分离</h4><p>​    通过 <code>DllPlugin</code> 或者 <code>Externals</code> 进行静态依赖包的分离。由于 CommonsChunkPlugin 每次构建会重新构建一次 vendor，所以出于效率考虑，使用 <code>DllPlugin</code> 将第三方库单独打包到一个文件    中，只有依赖自身发生版本变化时才会重新打包。</p><h4 id="5-打包资源的压缩，多进程压缩"><a href="#5-打包资源的压缩，多进程压缩" class="headerlink" title="5. 打包资源的压缩，多进程压缩"></a>5. 打包资源的压缩，多进程压缩</h4><p>​    <em>打包资源的压缩</em>：</p><ul><li><p>JS 压缩：<code>UglifyjsWebpackPlugin</code></p></li><li><p>HTML 压缩：<code>HtmlWebpackPlugin</code></p></li><li><p>CSS 压缩：<code>MiniCssExtractPlugin</code></p></li><li><p>图片压缩：<code>image-webpack-loader</code></p></li><li><p>Gzip 压缩：不包括图片</p></li></ul><p>​    <em>多进程压缩</em>：</p><p>​    因为自带的 <code>UglifyjsWebpackPlugin</code> 压缩插件是单线程运行的，而 <code>TerserWebpackPlugin</code> 可以并发运行压缩功能（多进程）。所以通    过 <code>TerserWebpackPlugin</code> 代替自带的 <code>UglifyjsWebpackPlugin</code> 插件。</p><h4 id="6-Scope-Hoisting作用域提升"><a href="#6-Scope-Hoisting作用域提升" class="headerlink" title="6. Scope Hoisting作用域提升"></a>6. Scope Hoisting作用域提升</h4><p>Webpack 会把引入的 js 文件 “提升到” 它的引入者顶部。作用域提升可以让 Webpack 打包出来的 代码文件更小，运行速度更快。</p><p><code>Scope Hoisting</code> 的实现原理其实很简单：分析出模块之间的依赖关系，尽可能将打散的模块合并到一个函数中，前提是不能造成代码冗余。因此只有那些被引用了一次的模块才能被合并。</p><h2 id="SSR服务端渲染"><a href="#SSR服务端渲染" class="headerlink" title="SSR服务端渲染"></a>SSR服务端渲染</h2><p>  渲染过程在服务器端完成，最终的渲染结果 HTML 页面通过 HTTP 协议发送给客户端，又被认为是‘同构’或‘通用’，如果项目中有大量的detail页面，相互特别频繁，建议选择服务端渲染。</p><p>Vue的Nuxt.js和React的next.js都是服务端渲染的方法。</p>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;代码执行更快&lt;/li&gt;
&lt;li&gt;文件加载更快，首屏加载优化&lt;/li&gt;
&lt;li&gt;webpack性能优化&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="front-end" scheme="http://example.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>浏览器网络相关</title>
    <link href="http://example.com/2021/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/02/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/</id>
    <published>2021-02-28T11:29:52.936Z</published>
    <updated>2020-12-25T00:54:15.230Z</updated>
    
    <content type="html"><![CDATA[<ol><li>浏览器：repaint，reflow，cookie,session,跨域，缓存，URL参数解析</li><li>网络：http1，http2，状态码，http，https，get，post，三次握手</li></ol><span id="more"></span><h2 id="reflow-回流-和repaint-重绘-优化"><a href="#reflow-回流-和repaint-重绘-优化" class="headerlink" title="reflow(回流)和repaint(重绘)优化"></a>reflow(回流)和repaint(重绘)优化</h2><ol><li><p>重绘与回流</p><ul><li><p>重绘repaint: 非结构就如背景色变化时触发repaint。</p></li><li><p>回流reflow:当页面布局和几何属性引起的改变触发reflow，比如宽高位置的变化。</p></li><li><p>回流必将引起重绘，但是重绘不一定会引起回流；二者都会造成体验不佳</p></li></ul></li><li><p>如何减少重绘和回流?</p><ul><li><p>通过classname或cssText一次性修改样式, 而非一个一个改 </p></li><li><p>离线模式: 克隆要操作的结点, 操作后再与原始结点交换, 类似于虚拟DOM </p></li><li><p>绝对布局的DOM, 不会造成大量reflow</p></li><li><p>p不要嵌套太深, 不要超过六层</p></li></ul></li></ol><ul><li><p>js 尽量减少对样式的操作，能用 css 完成的就用 css</p></li><li><p>对 dom 操作尽量少，能用 createDocumentFragment 的地方尽量用</p></li><li><p>如果必须要用 js 操作样式，能合并尽量合并不要分多次操作</p></li><li><p>resize 事件 最好加上防抖，能尽量少触发就少触发</p></li><li><p>加载图片的时候，提前写好宽高</p></li></ul><h2 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h2><ul><li>首先会进行 url 解析，根据 dns 系统进行 ip 查找</li><li>根据 ip 就可以找到服务器，然后浏览器和服务器会进行 TCP 三次握手建立连接，如果此时是 https 的话，还会建立 TLS 连接以及协商加密算法，这里涉及到”https 和 http 的区别”</li><li>连接建立之后浏览器开始发送请求获取文件，这时这里还会出现一种情况就是缓存，建立连接后是走缓存还是直接重新获取，需要看后台设置，这里涉及到”浏览器缓存机制”，</li><li>首先获取 html 文件，构建 DOM 树，这个过程是边下载边解析，并不是等 html 文件全部下载完了，再去解析 html，这样比较浪费时间，而是下载一点解析一点</li><li>解析到 html 头部时候，去找相应的css文件，而css 放头部,js 放尾部，不同的位置会造成渲染的不同，</li><li>解析到了 html 头部发现有 css 文件，此时下载 css 文件，css 文件也是一边下载一边解析的，构建的是 CSSOM 树，当 DOM 树和 CSSOM 树全部构建完之后，浏览器会把 DOM 树和 CSSOM 树构建成渲染树。</li><li>样式计算, DOM树 和 CSSOM树有了之后，浏览器开始样式计算，主要是为 DOM 树上的节点找到对应的样式</li><li>构建布局树，样式计算完之后开始构建布局树。主要是为DOM树上的节点找到页面上对应位置以及一些”display:none”元素的隐藏。</li><li>构建分层树，布局树完成后浏览器还需要建立分层树，主要是为了满足滚动条，z-index，position 这些复杂的分层操作</li><li>将分层树图块化，利用光栅找到视图窗口下的对应的位图。主要是因为一个页面可能有几屏那么长，一下渲染出来比较浪费，所以浏览器会找到视图窗口对应的图块，将这部分的图块进行渲染</li><li>载入解析到的资源文件，渲染页面，完成。在渲染的过程中还会出现重排和重绘。</li></ul><h2 id="localStorage-与-sessionStorage"><a href="#localStorage-与-sessionStorage" class="headerlink" title="localStorage 与 sessionStorage"></a>localStorage 与 sessionStorage</h2><ul><li><strong>共同点</strong>: 都保存在浏览器端, 且同源</li><li>localStorage 与 sessionStorage 统称webStorage,保存在浏览器,不参与服务器通信,大小为5M</li><li><strong>生命周期不同</strong>: localStorage永久保存, sessionStorage当前会话, 都可手动清除</li><li><strong>作用域不同</strong>: 不同浏览器不共享local和session, 不同会话不共享session</li><li><strong>Cookie</strong>: 设置的过期时间前一直有效, 大小4K.有个数限制, 各浏览器不同, 一般为20个.携带在HTTP头中, 过多会有性能问题.可自己封装, 也可用原生</li></ul><h2 id="cookie与session的区别总结"><a href="#cookie与session的区别总结" class="headerlink" title="cookie与session的区别总结"></a>cookie与session的区别总结</h2><p>  1.Cookie是将会话状态保存在浏览器的技术；Session是将会话状态保存在服务器的技术；</p><p>  2.Cookie中的数据保存时间较长(可调)；Session中的数据保存时间较短，约为30分钟(可调)；</p><p>  3.Cookie数据的安全性和稳定性较差(原因是数据保存在用户手中，用户可进行任意修改，病毒可轻易攻击)；</p><p>​     Session数据的安全性和稳定性较高(服务器的安全性高，数据存在服务器上安全性高)；</p><p>  4.Cookie的大小有限制，大小约为4kb。Session的大小无限制，理论上可无限大</p><p>  5 保存数据，cookie只能保存字符串类型的数据，session可以保存任意类型的数据。</p><p>​        cookie对象和session对象一样是用来保存特定的用户相关的数据，用户和服务器连接时，就建立了一个session，服务器为之分配了一个唯一的sessionID。很多时候session是和cookie共同使用的，客户端将请求和cookie发送至服务器，session根据唯一sessionID和cookie辨别用户。这样既增加了安全机制，也可以方便用户操作。</p><h2 id="跨域，预检请求，同源策略"><a href="#跨域，预检请求，同源策略" class="headerlink" title="跨域，预检请求，同源策略"></a>跨域，预检请求，同源策略</h2><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求:"></a>预检请求:</h3><p>请求分为简单请求和非简单请求，非简单请求也就是options预检请求。需预检的请求要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。服务器若接受此次跨域请求，那么当options请求成功返回后，浏览器继续发起第二次请求，也就是真正的ajax请求。以后每次浏览器正常的<strong>CORS</strong>请求，就都跟简单请求一样，会有一个<strong>Origin</strong>头信息字段。</p><p>大概有三种方法会产生options预检请求：</p><p>​    1、请求方法不是GET/HEAD/POST</p><p>​    2、POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain</p><p>​    3、请求设置了自定义的header字段</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收</p><p>同源策略限制内容有：</p><ul><li>Cookie、LocalStorage、IndexedDB 等存储性内容</li><li>DOM节点</li><li>AJAX跨域请求的数据</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源</p><p>同源策略限制了通过 XMLHttpRequest 的方式将站点数据发送给跨域的站点。所以就会发生开发中很常见的请求跨域问题</p><p>防止XSS、CSFR等攻击, 协议+域名+端口不同</p><h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h3><h4 id="1-jsonp：动态添加script标签"><a href="#1-jsonp：动态添加script标签" class="headerlink" title="1. jsonp：动态添加script标签"></a>1. jsonp：动态添加script标签</h4><p>   实现：JSONP是通过 script 标签加载数据的方式去获取数据当做 JS 代码来执行。提前在页面上声明一个jsonp回调函数，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。换句话说，JSONP 需要对应接口的后端的配合才能实现。</p><p>   缺点：JSONP只能发GET请求，因为本质上script加载资源就是GET</p><h4 id="2-cors-跨域资源共享"><a href="#2-cors-跨域资源共享" class="headerlink" title="2. cors(跨域资源共享)"></a>2. cors(跨域资源共享)</h4><h5 id="a-简单请求的实现"><a href="#a-简单请求的实现" class="headerlink" title="a.  简单请求的实现"></a>a.  简单请求的实现</h5><ul><li><p>浏览器直接发出 CORS 请求（浏览器自动在请求头信息中添加 Origin 字段标识请求的来源，服务器根据配置的请求源决定是否返回这次请求）</p></li><li><p>请求源在服务器允许范围内，服务器在响应头中会增加以下几个字段</p></li><li><p>```js<br>//发起请求的请求源或者<em>，如果要允许浏览器发送 Cookie 则不能设置成</em>，必须是明确的请求源<br>Access-Control-Allow-Origin: <a href="http://xxx.com">http://xxx.com</a><br>//值只能为 true，表示允许浏览器发送 Cookie 到服务器，需要客户端同时给 AJAX 请求设置 withCredentials = true 属性<br>//服务器在不需要浏览器发送 Cookie 时直接去掉该字段<br>Access-Control-Allow-Credentials: true<br>//CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：<br>//Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、<br>//Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。<br>Access-Control-Expose-Headers: FooBar</p><p>Content-Type: text/html; charset=utf-8复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 请求源不在服务器允许范围内，服务器会返回一个正常的（不带上述几个字段）的响应。浏览器发现响应头中没有 Access-Control-Allow-Origin 字段，则在XMLHttpRequest 对象的 onerror 回调函数中捕捉错误（这种错误无法通过 HTTP 的状态码来识别，状态码有可能是 200）</span><br><span class="line"></span><br><span class="line">##### b. 非简单请求的实现</span><br><span class="line"></span><br><span class="line">- 发起预检请求</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  -- 在正式通信之前，发起一次HTTP查询请求，当前网页所在的域名是否在服务器的许可名单之中，可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。OPTIONS &#x2F;cors HTTP&#x2F; 1.1 &#x2F;&#x2F;预检请求的方法</span><br><span class="line">  Origin:xxx.com &#x2F;&#x2F; 请求源</span><br><span class="line">  Access-Control-Request-Method:POST &#x2F;&#x2F;表明后续发送的 CORS 请求会应用到的请求方法</span><br><span class="line">  Access-Control-Request-Headers:&#x2F;&#x2F;指定后续发送的 CORS 请求会携带哪些额外的请求头字段复制代码</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>预检请求回应</p></li><li><p>```js<br>  — 服务器收到”预检”请求以后，检查了 Origin、Access-Control-Request-Method 和Access-Control-Request-Headers 字段以后，确认允许跨域请求，做出回应// 表示服务器允许浏览器在下面字段值定义的域中进行跨域请求，<br>// * 号则表示允许所有域进行跨域请求<br>Access-Control-Allow-Origin: <a href="http://xxx.com">http://xxx.com</a><br>// 表明服务器支持的所有跨域请求的方法<br>Access-Control-Allow-Methods: GET, POST, PUT<br>// 表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段<br>Access-Control-Allow-Headers: X-Custom-Header<br>//值只能为 true，表示允许浏览器发送 Cookie 到服务器，需要客户端同时给 AJAX 请求设置 withCredentials = true 属性<br>//服务器在不需要浏览器发送 Cookie 时直接去掉该字段<br>Access-Control-Allow-Credentials: true</p><pre><code>   --  如果浏览器否定&quot;预检&quot;请求（即服务器器不会返回 Access-Control-Allow-Origin 响应头），此时服务器会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。然后浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest 对象的 onerror 回调函数捕获。控制台会抛出错误：XMLHttpRequest cannot load http://xxx.com.</code></pre><p>Origin <a href="http://xxx1.com">http://xxx1.com</a> is not allowed by Access-Control-Allow-Origin.复制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   - 浏览器发起正常的 CORS 请求（跟简单请求时一样）</span><br><span class="line"></span><br><span class="line">   ##### c. 操作cookie的条件：</span><br><span class="line"></span><br><span class="line">   - 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</span><br><span class="line">   - 浏览器发起ajax需要指定withCredentials 为true</span><br><span class="line">   - 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</span><br><span class="line"></span><br><span class="line">#### 3. 代理</span><br><span class="line"></span><br><span class="line">正向代理</span><br><span class="line"></span><br><span class="line">nginx反向代理</span><br><span class="line"></span><br><span class="line">##  浏览器的缓存机制</span><br><span class="line"></span><br><span class="line">1. 浏览器缓存就是把一个已经请求过的资源拷贝一份存储起来，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求.</span><br><span class="line"></span><br><span class="line">2. 作用: 减少网络传输的损耗以及降低服务器压力。</span><br><span class="line"></span><br><span class="line">3. 优先级: 强制缓存 &gt; 协商缓存; cache-control &gt; Expires &gt; Etag &gt; Last-modified</span><br><span class="line"></span><br><span class="line">4. http缓存机制是根据HTTP报文的缓存标识进行的，浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识，浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</span><br><span class="line"></span><br><span class="line">### 强缓存</span><br><span class="line"></span><br><span class="line">​     **强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程**，如果不存在缓存结果和缓存标识，直接向服务器发送请求。如果存在缓存结果和缓存标识，但失效了，就使用协商缓存。如果缓存结果和缓存标识没有失效，就使用强缓存，强缓存是在浏览器端查找，不和服务器交互。当浏览器向服务器发送请求的时候，服务器会将**缓存规则**放入HTTP响应的报文的HTTP头中和请求结果一起返回给浏览器，</span><br><span class="line">​     **控制强制缓存的字段分别是Expires和Cache-Control**，其中Cache-Conctrol的优先级比Expires高。Expires是HTTP&#x2F;1.0的字段，到了HTTP&#x2F;1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用**客户端的时间**与**服务端返回的时间**做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。</span><br><span class="line"></span><br><span class="line">### 协商缓存</span><br><span class="line"></span><br><span class="line">​     **协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程**，协商缓存生效之后直接返回304，资源没有更新。如果协商缓存失败，重新返回200和请求的结果，资源也更新了。 </span><br><span class="line">​    Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。 </span><br><span class="line">​    Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</span><br><span class="line"></span><br><span class="line">##  http和https</span><br><span class="line"></span><br><span class="line">- http: 最广泛网络协议，BS模型，浏览器高效。</span><br><span class="line">- https: 安全版，通过SSL加密，加密传输，身份认证，密钥</span><br><span class="line"></span><br><span class="line">1. https相对于http加入了ssl层, 加密传输, 身份认证;</span><br><span class="line">2. 需要到ca申请收费的证书;</span><br><span class="line">3. 安全但是耗时多，缓存不是很好;</span><br><span class="line">5. 连接方式不同, 端口号也不同, http是80, https是443</span><br><span class="line"></span><br><span class="line">## http请求头</span><br><span class="line"></span><br><span class="line">1. Accept: 浏览器接受的格式</span><br><span class="line">2. Accept-Encoding: 浏览器接受的编码格式</span><br><span class="line">3. Accept-Language: 浏览器接受的语言，用于服务器判断多语言</span><br><span class="line">4. Cache-Control: 控制缓存的时效性</span><br><span class="line">5. Connection: 连接方式，keep-alive且服务端支持，则会复用TCP连接</span><br><span class="line">6. Host: HTTP访问使用的域名</span><br><span class="line">7. If-Modifided-Since: 上次访问时的更改时间，如果服务端认为此时间后自己没有更新，则会给出304响应</span><br><span class="line">8. If-None-Match: 上次访问时使用的E-Tag，通常是页面的信息摘要，比更改时间更加准确一些</span><br><span class="line">9. User-Agent: 客户端标识，因为一些历史原因，多数浏览器的这个字段十分复杂包括操作系统，浏览器内核，版本号等待</span><br><span class="line">10. Cookie:客户端存储的cookie字符串</span><br><span class="line"></span><br><span class="line">##  http状态码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200  OK   正常返回信息<br>201  Created  请求成功并且服务器创建了新的资源<br>202  Accepted  服务器已接受请求，但尚未处理<br>301  Moved Permanently  请求的网页已永久移动到新位置。<br>302 Found  临时性重定向。<br>303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。<br>304  Not Modified  自从上次请求后，请求的网页未修改过。</p></li></ul><p>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401 Unauthorized  请求未授权。<br>403 Forbidden  禁止访问。<br>404 Not Found  找不到如何与 URI 相匹配的资源。</p><p>500 Internal Server Error  最常见的服务器端错误。<br>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## http,tcp,UDP</span><br><span class="line"></span><br><span class="line">- TCP（Transmission Control Protocol：传输控制协议；面向连接，可靠传输</span><br><span class="line"></span><br><span class="line">- UDP（User Datagram Protocol）：用户数据报协议；面向无连接，不可靠传输</span><br><span class="line"></span><br><span class="line">  osi七层应用模型:</span><br><span class="line"></span><br><span class="line">  1、应用层协议：HTTP、FTP、SMTP、DNS、TELNET、HTTPS等；</span><br><span class="line"></span><br><span class="line">  2、表示层不需要协议；</span><br><span class="line"></span><br><span class="line">  3、会话层不需要协议；</span><br><span class="line"></span><br><span class="line">  4、传输层协议：TCP、UDP等； </span><br><span class="line"></span><br><span class="line">  5、网络层协议：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP等； IP地址 32位，</span><br><span class="line"></span><br><span class="line">  6、数据链路层协议：802.11、802.16、Wi-Fi、WiMAX、ATM、DTM、GPRS、EVDO、HSPA等；MAC地址 48位</span><br><span class="line"></span><br><span class="line">  7、物理层协议：FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD等 。</span><br><span class="line"></span><br><span class="line">## http1.0， http1.1，http2.0详解</span><br><span class="line"></span><br><span class="line">### HTTP1.0与HTTP 1.1的主要区别</span><br><span class="line"></span><br><span class="line">1. 长连接</span><br><span class="line"></span><br><span class="line"> - a. 短连接：客户端和服务器每进行一次http操作，就建立一次连接，任务结束就中断连接。</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><pre><code>   - 短连接的操作步骤是：     建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">b. 长连接：客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用一条已经建立的连接。</span><br><span class="line"></span><br></pre></td></tr></table></figure>  长连接的操作步骤是：  建立连接——数据传输...（保持连接）...数据传输——关闭连接  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - c. HTTP实现长连接的方式</span><br><span class="line"></span><br><span class="line">    HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。</span><br><span class="line"></span><br><span class="line">   HTTP是基于TCP&#x2F;IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用一个长连接来发多个请求。</span><br><span class="line"></span><br><span class="line">2. 节约带宽</span><br><span class="line"></span><br><span class="line">   - HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接收到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。</span><br><span class="line">   - 另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</span><br><span class="line"></span><br><span class="line">3. 增加catch-control缓存字段</span><br><span class="line"></span><br><span class="line">4. 增加HOST域</span><br><span class="line"></span><br><span class="line">​        HTTP1.0是没有host域的，HTTP1.1才支持这个参数。</span><br><span class="line"></span><br><span class="line">### HTTP1.1与HTTP 2.0的主要区别</span><br><span class="line"></span><br><span class="line">- 多路复用</span><br><span class="line"></span><br><span class="line">  HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</span><br><span class="line"></span><br><span class="line">  当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</span><br><span class="line"></span><br><span class="line">  TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</span><br><span class="line"></span><br><span class="line">- 二进制分帧</span><br><span class="line"></span><br><span class="line">  HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</span><br><span class="line"></span><br><span class="line">- 首部压缩</span><br><span class="line"></span><br><span class="line">  HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</span><br><span class="line"></span><br><span class="line">- 服务器推送</span><br><span class="line"></span><br><span class="line">  HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</span><br><span class="line"></span><br><span class="line">  有了HTTP2.0的服务器推送，HTTP1.x时代的内嵌资源的优化手段也变得没有意义了。而且使用服务器推送的资源的方式更加高效，因为客户端还可以缓存起来，甚至可以由不同的页面共享（依旧遵循同源策略</span><br><span class="line"></span><br><span class="line">**总结如下：**</span><br><span class="line"></span><br><span class="line">**http1.0**</span><br><span class="line"></span><br><span class="line">无状态无连接</span><br><span class="line"></span><br><span class="line">**http1.1**</span><br><span class="line"></span><br><span class="line">持久连接</span><br><span class="line"></span><br><span class="line">请求管道化</span><br><span class="line"></span><br><span class="line">增加缓存处理(新的字段如cache-control)</span><br><span class="line"></span><br><span class="line">增加Host字段，支持断点传输等</span><br><span class="line"></span><br><span class="line">**http2.0**</span><br><span class="line"></span><br><span class="line">二进制分帧</span><br><span class="line"></span><br><span class="line">多路复用(或连接共享)</span><br><span class="line"></span><br><span class="line">头部压缩</span><br><span class="line"></span><br><span class="line">服务器推送</span><br><span class="line"></span><br><span class="line">##  get请求和post请求的区别</span><br></pre></td></tr></table></figure></code></pre><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符<br>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，<br>也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</p><p>在以下情况中，只能使用 POST 请求：<br>无法使用缓存文件（更新服务器上的文件或数据库）<br>向服务器发送大量数据（POST 没有数据量限制）<br>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">## 正向代理和反向代理</span><br><span class="line"></span><br><span class="line">**正向代理(客户端)**</span><br><span class="line"></span><br><span class="line">（1）访问原来无法访问的资源，如google</span><br><span class="line">（2） 可以做缓存，加速访问资源</span><br><span class="line">（3）对客户端访问授权，上网进行认证</span><br><span class="line">（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</span><br><span class="line"></span><br><span class="line">**反向代理(服务器端)**</span><br><span class="line"></span><br><span class="line">（1）保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击大型网站，</span><br><span class="line"></span><br><span class="line">​ 通常将反向代理作为公网访问地址，Web服务器是内网。</span><br><span class="line"></span><br><span class="line">（2）负载均衡，通过反向代理服务器来优化网站的负载</span><br><span class="line"></span><br><span class="line">## 三次握手四次挥手</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送  后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。<br>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束<br>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。<br>```</p><ol><li><p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p></li><li><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p></li><li><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。</p></li></ol><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接</p><p>四次挥手：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文，断开连接。</p><h2 id="url查询参数解析"><a href="#url查询参数解析" class="headerlink" title="url查询参数解析"></a>url查询参数解析</h2>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;浏览器：repaint，reflow，cookie,session,跨域，缓存，URL参数解析&lt;/li&gt;
&lt;li&gt;网络：http1，http2，状态码，http，https，get，post，三次握手&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="front-end" scheme="http://example.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>vuejs-base-interview</title>
    <link href="http://example.com/2021/02/28/vuejs-base-interview/"/>
    <id>http://example.com/2021/02/28/vuejs-base-interview/</id>
    <published>2021-02-28T11:29:52.930Z</published>
    <updated>2020-12-25T00:54:15.212Z</updated>
    
    <content type="html"><![CDATA[<p>整理一下vuejs的面试题。个人觉得框架方面还是要从源码原理出发，对于数据响应式，虚拟dom的源码原理应该刻意重复的练习。曾经看过某节目尤雨溪说自己学习的方法就是看源码写源码，大道至简。</p><span id="more"></span><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>   Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，  我们称这是 Vue 的生命周期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate: 组件实例被创建之初，组件的属性生效之前  </span><br><span class="line">created:  组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用 </span><br><span class="line">beforeMount: 在挂载开始之前被调用：相关的 render 函数首次被调用  </span><br><span class="line">mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子  </span><br><span class="line">beforeUpdate: 组件数据更新之前调用，发生在虚拟 DOM 打补丁之前  </span><br><span class="line">update: 组件数据更新之后  </span><br><span class="line">activited: keep-alive 专属，组件被激活时调用  </span><br><span class="line">deadctivated: keep-alive 专属，组件被销毁时调用  </span><br><span class="line">beforeDestory: 组件销毁前调用  </span><br><span class="line">destoryed: 组件销毁后调用</span><br></pre></td></tr></table></figure><h2 id="组件中-data-为什么是一个函数？"><a href="#组件中-data-为什么是一个函数？" class="headerlink" title="组件中 data 为什么是一个函数？"></a>组件中 data 为什么是一个函数？</h2><ol><li>vue组件可能会需要复用，所以存在多个实例，如果使用对象形式定义data，可能会导致它们共用一个data对象，那么状态变更将会影响所有组件实例。这当然是不合理的。</li><li>所以采用函数形式定义，在initData时候将其作为工厂函数返回全新data对象，有效规避多实例之间的状态污染问题。</li><li>但是在Vue根实例创建过程中不存在这种限制，根实例在合并选项的时候能拿到实例，所以可以有效的躲避data选项的校验。因为根实例只能有一个。 </li></ol><h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><ol><li><p>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。</p></li><li><p>watch 侦听器 : 更多的是监听的作用,无缓存,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。</p></li><li><p>运用场景：如果需要进行数值计算并依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。如果需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用  watch  选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</p></li></ol><h2 id="v-if-v-show-v-html的原理"><a href="#v-if-v-show-v-html的原理" class="headerlink" title="v-if,v-show,v-html的原理"></a>v-if,v-show,v-html的原理</h2><ol><li><p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。v-if在源码中就是一个三元表达式，是需要经过编译成render函数执行的，像template都是编译成render函数执行的。</p></li><li><p>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p></li><li><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p></li></ol><h2 id="v-if和v-for的优先级"><a href="#v-if和v-for的优先级" class="headerlink" title="v-if和v-for的优先级"></a>v-if和v-for的优先级</h2><ol><li>v-for优先于v-if被解析</li><li>v-for和v-if同时出现，v-for优先级高，就相当于在每一次for循环中都去执行一下if判断。</li><li>所以说就不应该把它们放一起，因为哪怕我们只渲染列表中一小部分元素，也得在每次重渲染的时候遍历整个列表。</li><li>一般是在向外层去写v-if，然后再写v-for，这样就是在if判断之后再去for循环。</li><li>实际场景：<ul><li>为了过滤列表中的项目 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>)。此时定义一个计算属性 (比如 <code>activeUsers</code>)，让其返回过滤后的列表即可。</li><li>为了避免渲染本应该被隐藏的列表 (比如 <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>)。此时把 <code>v-if</code> 移动至容器元素上 (比如 <code>ul</code>、<code>ol</code>)即可。</li></ul></li></ol><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><ol><li><p>vue中双向绑定是一个指令v-model，可以绑定一个动态值到视图，同时视图中变化能改变该值。v-model是语法糖，默认情况下相当于:value和@input。</p></li><li><p>使用v-model可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好</p></li><li><p>原生的表单项可以直接使用v-model，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件</p></li><li><p>做过测试之后发现，输出包含v-model模板的组件渲染函数，会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作。</p></li></ol><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>   vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,<br>​   在数据变动时发布消息给订阅者,触发 响应的监听回调<br><img src="http://yangwenxu.cn/assets/images/vue-reactive.png" alt="vue-reactive" style="zoom: 80%;" /></p><h3 id="核心实现类"><a href="#核心实现类" class="headerlink" title="核心实现类:"></a>核心实现类:</h3><ol><li><p>Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新</p></li><li><p>Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。</p></li><li><p>Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种</p></li><li><p>Watcher 和 Dep 的关系：watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。</p></li></ol><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><ol><li>initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集</li><li>initState 时,对侦听属性初始化时,触发 user watcher 依赖收集</li><li>render()的过程,触发 render watcher 依赖收集</li><li>re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。</li></ol><h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><ol><li>组件中对响应的数据进行了修改,触发 setter 的逻辑</li><li>调用 dep.notify()</li><li>遍历所有的 subs（Watcher 实例）,调用每一个 watcher 的 update 方法。</li></ol><h3 id="原理总结"><a href="#原理总结" class="headerlink" title="原理总结"></a>原理总结</h3><ol><li><p>所谓数据响应式就是能够使数据变化可以被检测并对这种变化做出响应的机制。</p></li><li><p>mvvm框架中要解决的一个核心问题是连接数据层和视图层，通过数据驱动应用，数据变化，视图更新，要做到这点的就需要对数据做响应式处理，这样一旦数据发生变化就可以立即做出更新处理。</p></li><li><p>以vue为例说明，通过数据响应式加上虚拟DOM和patch算法，可以使我们只需要操作数据，完全不用接触繁琐的dom操作，从而大大提升开发效率，降低开发难度。</p></li><li><p>vue2中的数据响应式会根据数据类型来做不同处理，如果是对象则采用Object.defineProperty()的方式定义数据拦截，当数据被访问或发生变化时，我们感知并作出响应；如果是数组则通过覆盖该数组原型的方法，扩展它的7个变更方法，使这些方法可以额外的做更新通知，从而作出响应。这种机制很好的解决了数据响应化的问题，但在实际使用中也存在一些缺点：比如初始化时的递归遍历会造成性能损失；新增或删除属性时需要用户使用Vue.set/delete这样特殊的api才能生效；对于es6中新产生的Map、Set这些数据结构不支持等问题。</p></li><li><p>为了解决这些问题，vue3重新编写了这一部分的实现：利用ES6的Proxy机制代理要响应化的数据，它有很多好处，编程体验是一致的，不需要使用特殊api，初始化性能和内存消耗都得到了大幅改善；另外由于响应化的实现代码抽取为独立的reactivity包，使得我们可以更灵活的使用它，我们甚至不需要引入vue都可以体验。</p></li></ol><h2 id="vm-set-实现原理"><a href="#vm-set-实现原理" class="headerlink" title="vm.$set()实现原理"></a>vm.$set()实现原理</h2><ol><li><p>首先，需要考虑vue能不能直接监测到数组的变化，当然是不能的。但其实object.defineProperty是可以监测到数组的变化，但这个变化也只是数组内部已有元素的变化，还是监测不到数组内部新增元素或属性的变化。但其实vue内部就根本没有用object.defineProperty来检测这种变化(官方是说受到现代JavaScript的限制)，而是把这种监测机制绑定在了改变数组的七种方法上面，执行这些方法就可以让数据变成响应式的。   </p></li><li><p>受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。</p></li><li><p>Vue 如何解决对象新增属性不能响应的问题：</p><p> (1). 如果目标是数组,使用 vue 实现的变异方法 splice 实现响应式<br> (2). 如果目标是对象,判断属性存在,即为响应式,直接赋值<br> (3). 如果 target 本身就不是响应式,直接赋值<br> (4). 如果属性不是响应式,则调用 defineReactive 方法进行响应式处理</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">target: <span class="built_in">Array</span>&lt;any&gt; | <span class="built_in">Object</span>, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// target 为数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splice()执行有误</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key);</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式</span></span><br><span class="line">    target.splice(key, <span class="number">1</span>, val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以上都不成立, 即开始给target创建一个全新的属性</span></span><br><span class="line">  <span class="comment">// 获取Observer实例</span></span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__;</span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进行响应式处理</span></span><br><span class="line">  defineReactive(ob.value, key, val);</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-的渲染过程"><a href="#Vue-的渲染过程" class="headerlink" title="Vue 的渲染过程"></a>Vue 的渲染过程</h2><p>  <img src="http://yangwenxu.cn/assets/images/vue-render.png" alt="vue-render" style="zoom: 80%;" /></p><ol><li><p>调用 compile 函数,生成 render 函数字符串 ,编译过程如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. parse 函数解析 template,生成 ast(抽象语法树)</span><br><span class="line">b. optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)</span><br><span class="line">c. generate 函数将生成的AST抽象语法树 render成 函数字符串</span><br></pre></td></tr></table></figure></li><li><p>调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象</p></li><li><p>调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素</p></li></ol><h2 id="vue中key的作用"><a href="#vue中key的作用" class="headerlink" title="vue中key的作用"></a>vue中key的作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span>(<span class="params">children, beginIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, key;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key;</span><br><span class="line">    <span class="keyword">if</span> (isDef(key)) map[key] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>key的作用主要是为了更高效的更新虚拟DOM。</p></li><li><p>vue在patch过程中需要判断两个节点是否是同一个节点，这时候主要是判断两者的key和元素类型等，在渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，它的值就是undefined，则可能永远认为这是两个相同节点，哪怕它们实际上不是，也只能去做更新操作，这会导致大量的DOM更新，使得整个patch过程比较低效，影响性能。</p></li><li><p>实际使用中在渲染一组列表时key必须设置，而且必须是唯一标识，应该避免使用数组索引作为key，这可能导致一些隐蔽的bug；vue中在使用相同标签元素过渡切换时，也会使用key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。</p></li></ol><h2 id="虚拟dom，diff算法"><a href="#虚拟dom，diff算法" class="headerlink" title="虚拟dom，diff算法"></a>虚拟dom，diff算法</h2><ol><li>diff算法是虚拟DOM技术的核心，vue里面主要是patch过程；通过新旧虚拟DOM作对比，将变化的地方转换为DOM操作</li><li>在vue 1中是没有patch的，因为界面中每个依赖都有专门的watcher负责更新，这样项目规模变大就会成为性能瓶颈，vue 2中为了降低watcher粒度，每个组件只有一个watcher，但是当需要更新的时候，需要执行patch过程才能精确找到发生变化的地方。</li><li>watcher会通知更新并执行其更新函数，它会执行渲染函数获取全新虚拟dom：newVnode，此时就会执行patch打补丁过程比对上次渲染结果oldVnode和新的渲染结果newVnode。</li><li>patch过程遵循深度优先、同层比较的策略；两个节点之间比较时，如果它们拥有子节点，会先比较子节点；比较两组子节点时，会假设头尾节点可能相同先做尝试，没有找到相同节点后才按照通用方式遍历查找；查找结束再按情况处理剩下的节点；借助key通常可以非常精确找到相同节点，因此整个patch过程非常高效。</li></ol><h2 id="nextTick的原理"><a href="#nextTick的原理" class="headerlink" title="nextTick的原理"></a>nextTick的原理</h2><h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>   JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤:</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p>​    主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。task 又分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。</p><h3 id="vue-的-nextTick-方法的实现原理"><a href="#vue-的-nextTick-方法的实现原理" class="headerlink" title="vue 的 nextTick 方法的实现原理:"></a>vue 的 nextTick 方法的实现原理:</h3><ol><li>nextTick是Vue提供的一个全局API，由于vue的异步更新策略导致我们对数据的修改不会立刻体现在dom变化上，此时如果想要立即获取更新后的dom状态，就需要使用这个方法。nextTick就是传一个回调函数进去，在里面执行dom操作即可。</li><li>vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</li><li>nextTick方法会在队列中加入一个回调函数，然后在callbacks里面加入我们传入的函数，在回调函数里面执行dom操作，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这样就能确保该函数在前面的dom操作完成后才调用。</li><li>降级策略：microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕，考虑到兼容问题, vue 做了 microtask 向 macrotask 的降级方案，在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout。</li></ol><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>父子组件通信、隔代组件通信、兄弟组件通信。</p><p><strong>（1）<code>props / $emit</code> 适用 父子组件通信</strong></p><p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p><p><strong>（3）<code>EventBus （$emit / $on）</code> 适用于 父子、隔代、兄弟组件通信</strong></p><p><strong>（4）<code>$attrs</code>/<code>$listeners</code> 适用于 隔代组件通信</strong></p><p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p><p><strong>（6）Vuex 适用于 父子、隔代、兄弟组件通信</strong></p><h2 id="vuex状态管理"><a href="#vuex状态管理" class="headerlink" title="vuex状态管理"></a>vuex状态管理</h2><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><ol><li><p>vuex是vue专用的状态管理库。它以全局方式集中管理应用的状态，并且可以保证状态变更的可预测性。</p></li><li><p>vuex主要解决的问题是多组件之间状态共享的问题，利用各种组件通信方式，我们虽然能够做到状态共享，但是往往需要在多个组件之间保持状态的一致性，这种模式很容易出现问题，</p></li><li><p>也会使程序逻辑变得复杂。vuex通过把组件的共享状态抽取出来，以全局单例模式管理，这样任何组件都能用一致的方式获取和修改状态，响应式的数据也能够保证简洁的单向数据流动，我们的代码将变得更结构化且易维护。</p></li><li><p>vuex的理解：首先是对核心概念的理解和运用，将全局状态放入state对象中，它本身一棵状态树，组件中使用store实例的state访问这些状态；然后有配套的mutation方法修改这些状态，并且只能用mutation修改状态，在组件中调用commit方法提交mutation；如果应用中有异步操作或者复杂逻辑组合，我们需要编写action，执行结束如果有状态修改仍然需要提交mutation，组件中调用这些action使用dispatch方法派发。最后是模块化，通过modules选项组织拆分出去的各个子模块，在访问状态时注意添加子模块的名称，如果子模块有设置namespace，那么在提交mutation和派发action时还需要额外的命名空间前缀。</p></li><li><p>vuex在实现单项数据流时需要做到数据的响应式，通过源码的学习发现是借用了vue的数据响应化特性实现的，它会利用Vue将state作为data对其进行响应化处理，从而使得这些状态发生变化时，能够导致组件重新渲染。</p></li></ol><h2 id="vue-router路由实现"><a href="#vue-router路由实现" class="headerlink" title="vue-router路由实现"></a>vue-router路由实现</h2><h3 id="hash-模式的实现原理"><a href="#hash-模式的实现原理" class="headerlink" title="hash 模式的实现原理"></a>hash 模式的实现原理</h3><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。hash 路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</li></ul><h3 id="history-模式的实现原理"><a href="#history-模式的实现原理" class="headerlink" title="history 模式的实现原理"></a>history 模式的实现原理</h3><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录。history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><h2 id="keep-alive-的实现原理和缓存策略"><a href="#keep-alive-的实现原理和缓存策略" class="headerlink" title="keep-alive 的实现原理和缓存策略"></a>keep-alive 的实现原理和缓存策略</h2><ol><li><p>获取 keep-alive 包裹着的第一个子组件对象及其组件名。</p></li><li><p>根据设定的 include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例</p></li><li><p>根据组件 ID 和 tag 生成缓存 Key,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(<strong>更新 key 的位置是实现 LRU 置换策略的关键</strong>)</p></li><li><p>在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置值,超过则根据 LRU 置换策略<strong>删除最近最久未使用的实例</strong>（即是下标为 0 的那个 key）</p></li><li><p>最后组件实例的 keepAlive 属性设置为 true,这个在渲染和执行被包裹组件的钩子函数会用到。</p></li></ol><h2 id="vue3的改动"><a href="#vue3的改动" class="headerlink" title="vue3的改动"></a>vue3的改动</h2><h3 id="1-监测机制的改变"><a href="#1-监测机制的改变" class="headerlink" title="1. 监测机制的改变"></a>1. 监测机制的改变</h3><p>  vue3.0 使用代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。<br>  这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><pre><code>- 只能监测属性，不能监测对象- 检测属性的添加和删除；- 检测数组索引和长度的变更；- 支持 Map、Set、WeakMap 和 WeakSet。</code></pre><h3 id="2-模板-作用域插槽"><a href="#2-模板-作用域插槽" class="headerlink" title="2. 模板(作用域插槽)"></a>2. 模板(作用域插槽)</h3><p>​      模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p><h3 id="3-对象式的组件声明方式"><a href="#3-对象式的组件声明方式" class="headerlink" title="3. 对象式的组件声明方式"></a>3. 对象式的组件声明方式</h3><p>​     vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p><h3 id="4-composition-api代替options-api"><a href="#4-composition-api代替options-api" class="headerlink" title="4. composition api代替options api"></a>4. composition api代替options api</h3><p>   避免了上下反复横跳</p><h3 id="5-vite打包"><a href="#5-vite打包" class="headerlink" title="5. vite打包"></a>5. vite打包</h3><p> 在开发环境中可以秒启动，其实是去掉了打包的过程，但在线上环境还是需要webpack打包的。</p><h3 id="6-其他方面的更改"><a href="#6-其他方面的更改" class="headerlink" title="6. 其他方面的更改"></a>6. 其他方面的更改</h3><p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul><h2 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h2><ul><li><strong>数据是否可变</strong>: react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变; vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。总之，react的性能优化需要手动去做，而vue的性能优化是自动的，但是vue的响应式机制也有问题，就是当state特别多的时候，Watcher也会很多，会导致卡顿，所以大型应用（状态特别多的）一般用react，更加可控。</li><li><strong>通过js来操作一切，还是用各自的处理方式</strong>: react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等; vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。</li><li><strong>类式的组件写法，还是声明式的写法</strong>: react是类式的写法，api很少; 而vue是声明式的写法，通过传入各种options，api和参数都很多。所以react结合typescript更容易一起写，vue稍微复杂。</li><li><strong>扩展不同</strong>: react可以通过高阶组件（Higher Order Components—HOC）来扩展，而vue需要通过mixins来扩展。</li><li><strong>什么功能内置，什么交给社区去做</strong>: react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些，<br>比如 redux的combineReducer就对应vuex的modules，<br>比如reselect就对应vuex的getter和vue组件的computed，<br>vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。</li></ul><h2 id="vuejs的优化策略"><a href="#vuejs的优化策略" class="headerlink" title="vuejs的优化策略"></a>vuejs的优化策略</h2><h3 id="1-路由懒加载"><a href="#1-路由懒加载" class="headerlink" title="1. 路由懒加载"></a>1. 路由懒加载</h3>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-keep-alive缓存页面"><a href="#2-keep-alive缓存页面" class="headerlink" title="2. keep-alive缓存页面"></a>2. keep-alive缓存页面</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;keep-alive&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="3-使用v-show复用DOM"><a href="#3-使用v-show复用DOM" class="headerlink" title="3. 使用v-show复用DOM"></a>3. 使用v-show复用DOM</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;cell&quot;&gt;</span><br><span class="line">    &lt;!--这种情况用v-show复用DOM，比v-if效果好--&gt;</span><br><span class="line">    &lt;div v-show&#x3D;&quot;value&quot; class&#x3D;&quot;on&quot;&gt;</span><br><span class="line">      &lt;Heavy :n&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;section v-show&#x3D;&quot;!value&quot; class&#x3D;&quot;off&quot;&gt;</span><br><span class="line">      &lt;Heavy :n&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="4-v-for-遍历避免同时使用-v-if"><a href="#4-v-for-遍历避免同时使用-v-if" class="headerlink" title="4. v-for 遍历避免同时使用 v-if"></a>4. v-for 遍历避免同时使用 v-if</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in activeUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;&gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">      &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">        computed: &#123;</span><br><span class="line">          activeUsers: function () &#123;</span><br><span class="line">            return this.users.filter(function (user) &#123;</span><br><span class="line">             return user.isActive</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="5-长列表性能优化"><a href="#5-长列表性能优化" class="headerlink" title="5. 长列表性能优化"></a>5. 长列表性能优化</h3><ul><li><p>如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    users: []</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">&quot;/api/users&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.users = <span class="built_in">Object</span>.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;recycle-scroller</span><br><span class="line">  class&#x3D;&quot;items&quot;</span><br><span class="line">  :items&#x3D;&quot;items&quot;</span><br><span class="line">  :item-size&#x3D;&quot;24&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &lt;template v-slot&#x3D;&quot;&#123; item &#125;&quot;&gt;</span><br><span class="line">    &lt;FetchItemView</span><br><span class="line">      :item&#x3D;&quot;item&quot;</span><br><span class="line">      @vote&#x3D;&quot;voteItem(item)&quot;</span><br><span class="line">    &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;recycle-scroller&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-事件的销毁"><a href="#6-事件的销毁" class="headerlink" title="6. 事件的销毁"></a>6. 事件的销毁</h3><p>  Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="built_in">this</span>.refresh, <span class="number">2000</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-图片懒加载"><a href="#7-图片懒加载" class="headerlink" title="7. 图片懒加载"></a>7. 图片懒加载</h3><p>  对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-lazy</span>=<span class="string">&quot;/static/img/1.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-第三方插件按需引入"><a href="#8-第三方插件按需引入" class="headerlink" title="8. 第三方插件按需引入"></a>8. 第三方插件按需引入</h3><p>  像element-ui这样的第三方组件库可以按需引入避免体积太大。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Button, Select &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> Vue.use(Button)</span><br><span class="line"> Vue.use(Select)</span><br></pre></td></tr></table></figure><h3 id="9-无状态的组件标记为函数式组件"><a href="#9-无状态的组件标记为函数式组件" class="headerlink" title="9. 无状态的组件标记为函数式组件"></a>9. 无状态的组件标记为函数式组件</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;cell&quot;&gt;</span><br><span class="line">    &lt;div v-if&#x3D;&quot;props.value&quot; class&#x3D;&quot;on&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;section v-else class&#x3D;&quot;off&quot;&gt;&lt;&#x2F;section&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;value&#39;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="10-子组件分割"><a href="#10-子组件分割" class="headerlink" title="10. 子组件分割"></a>10. 子组件分割</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ChildComp&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ChildComp: &#123;</span><br><span class="line">      methods: &#123;</span><br><span class="line">        heavy () &#123; &#x2F;* 耗时任务 *&#x2F; &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      render (h) &#123;</span><br><span class="line">        return h(&#39;div&#39;, this.heavy())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="11-变量本地化"><a href="#11-变量本地化" class="headerlink" title="11. 变量本地化"></a>11. 变量本地化</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :style&#x3D;&quot;&#123; opacity: start &#x2F; 300 &#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; result &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; heavy &#125; from &#39;@&#x2F;utils&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#39;start&#39;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    base () &#123; return 42 &#125;,</span><br><span class="line">    result () &#123;</span><br><span class="line">      const base &#x3D; this.base &#x2F;&#x2F; 不要频繁引用this.base</span><br><span class="line">      let result &#x3D; this.start</span><br><span class="line">      for (let i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        result +&#x3D; heavy(base)</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理一下vuejs的面试题。个人觉得框架方面还是要从源码原理出发，对于数据响应式，虚拟dom的源码原理应该刻意重复的练习。曾经看过某节目尤雨溪说自己学习的方法就是看源码写源码，大道至简。&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>reactjs-base-interview</title>
    <link href="http://example.com/2021/02/28/reactjs-base-interview/"/>
    <id>http://example.com/2021/02/28/reactjs-base-interview/</id>
    <published>2021-02-28T11:29:52.927Z</published>
    <updated>2020-12-25T00:54:15.206Z</updated>
    
    <content type="html"><![CDATA[<ol><li>组件：class类组件和hooks函数组件开发</li><li>context，redux数据状态管理</li><li>虚拟dom，fiber架构</li></ol><span id="more"></span><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><em>1. 初始渲染阶段：</em>这是组件即将开始其生命之旅并进入 DOM 的阶段。</p><p><em>2. 更新阶段：</em>一旦组件被添加到 DOM，它只有在 prop 或状态发生变化时才可能更新和重新渲染。这些只发生在这个阶段。</p><p><em>3. 卸载阶段：</em>这是组件生命周期的最后阶段，组件被销毁并从 DOM 中删除。</p><p>​    <strong>componentWillMount</strong>：在创建组件之后但在将其渲染到DOM中之前调用<br>​    <strong>componentDidMount</strong>：在第一个渲染之后调用；组件的DOM元素现在可用<br>​    <strong>componentWillReceiveProps</strong>：当属性更新时调用<br>​    <strong>shouldComponentUpdate</strong>：当收到新props时，此方法可以防止重新渲染以优化性能<br>​    <strong>componentWillUpdate</strong>：在收到新的props并且ComponentUpdate返回true时调用<br>​    <strong>componentDidUpdate</strong>：在组件更新后调用<br>​    <strong>componentWillUnmount</strong>：在组件从DOM中移除之前调用，允许您清理事件侦听器之类的</p><p>  React v16.3新引⼊了两个新的⽣命周期函 数：<br>  <strong>getDerivedStateFromProps</strong>，<strong>getSnapshotBeforeUpdate</strong></p><p>  <strong>getDerivedStateFromProps</strong> 会在调⽤ render ⽅法之前调⽤，并且在初始挂载及后续更新时都会被调⽤。它应返回⼀个对象来更新<br>  state，如果返回 null 则不更新任何内容。</p><p>  <strong>getSnapshotBeforeUpdate</strong> 在最近⼀次渲染输出（提交到 DOM 节点）之前调⽤。它使得组件能在发⽣更改之前从 DOM 中 捕获⼀    些信息（例如，滚动位置）。此⽣命周期的任何返回值将作 为参数传递给 componentDidUpdate()。</p><p>   V17可能会废弃的三个⽣命周期函数⽤<strong>getDerivedStateFromProps</strong> 替代，⽬前使⽤的话加上UNSAFE_：<strong>componentWillMount</strong>  <strong>componentWillReceiveProps</strong> <strong>componentWillUpdate</strong></p><h2 id="类组件和函数式组件"><a href="#类组件和函数式组件" class="headerlink" title="类组件和函数式组件"></a>类组件和函数式组件</h2><p>函数组件是无状态的（同样，小于 React 16.8版本），并返回要呈现的输出。它们渲染 UI 的首选只依赖于属性，因为它们比基于类的组件更简单、更具性能。react hooks的出现就是让函数式组件也具有类组件的能力。</p><h2 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h2><p>​    不需要基于类的组件、生命周期钩子和 this 关键字</p><p>​    通过将公共函数抽象到定制钩子中，使重用逻辑变得更容易</p><p>​    通过能够将逻辑与组件本身分离出来，使代码更具可读性和可测试性</p><ul><li><p>useState</p></li><li><p>usEffect</p><pre><code> React Hooks 提供了 Effect Hook，可以在函数组件中执行副作用操作，并且是在函数渲染    DOM完成后执行副作用操作。</code></pre></li><li><p>useContext</p><p>  跨层级组件通讯</p><p>  Provider：外层提供数据的组件 </p><p>  Consumer ：内层获取数据的组件</p></li><li><p>useReducer</p></li><li><p>useCallback</p></li><li><p>useMemo</p></li><li><p>useRef</p></li><li><p>useImperativeHandle</p></li><li><p>useLayoutEffect</p></li></ul><h2 id="react的refs"><a href="#react的refs" class="headerlink" title="react的refs"></a>react的refs</h2><p>Refs 是 React 中引用的简写。它是一个有助于存储对特定的 React 元素或组件的引用的属性，它将由组件渲染配置函数返回。用于对 render() 返回的特定元素或组件的引用。当需要进行 DOM 测量或向组件添加方法时，它们会派上用场。以下是应该使用 refs 的情况：</p><ul><li>需要管理焦点、选择文本或媒体播放时</li><li>触发式动画</li><li>与第三方 DOM 库集成</li></ul><h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><h3 id="redux-1"><a href="#redux-1" class="headerlink" title="redux"></a>redux</h3><p> <img src="http://yangwenxu.cn/assets/images/redux.png" alt="redux"></p><ol><li>createStore: 创建store ，来存储数据</li><li>reducer: 初始化state并定义state修改规则，修改状态函数</li><li>getState: 获取状态值</li><li>dispatch: 提交更新，通过dispatch⼀个action来提交对数据的修改</li><li>action:  action提交到reducer函数⾥，根据传⼊的action的type，返回新的 state</li><li>subscribe: 变更订阅</li></ol><h3 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h3><p>redux与react一起使用时需要手动在组件里通过subscribe监听state的变化并更新组件，这样的话每次都会重新调⽤render和getState，为了解决这样的问题，redux官方提供了react-redux的库，通过connect的方式连接state和react组件，达到自动监听的效果</p><p>提供了两个api </p><ol><li><p>Provider 为后代组件提供store</p></li><li><p>connect 为组件提供数据和变更⽅法</p></li></ol><p>connect是一个高阶组件，接收mapStateToProps和mapDispatchToProps参数，其中mapStateToProps的作用是将特定的state映射到组件的props上，mapDispatchToProps将dispatch(action)映射到props上，并在componentDidMount统一进行store的subscribe监听，当state变化时，被connect的所有组件都会进行一次render。</p><p>总结：Provider的本质是利用context统一传递，connect本质是将监听和获取state的逻辑进行统一抽取复用，这也是高阶组件的常用功能，被connect的组件变成了UI型组件，只需要从props中获取到状态进行渲染即可。</p><h3 id="redux-thunk，redux-logger"><a href="#redux-thunk，redux-logger" class="headerlink" title="redux-thunk，redux-logger"></a>redux-thunk，redux-logger</h3><p> <img src="http://yangwenxu.cn/assets/images/react-thunk.png" alt="redux-thunk"></p><p>Redux只是个纯粹的状态管理器，默认只⽀持同步，实现异步任务，⽐如延迟，⽹络请求，需要redux-thunk和 redux-logger中间件的⽀持</p><h3 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h3><p> <img src="http://yangwenxu.cn/assets/images/redux-saga.png" alt="redux-saga"></p><p>redux-thunk虽然支持了异步场景，但其存在的缺点也很明显：</p><p>1、使用回调的方式来实现异步，容易形成层层回调的面条代码</p><p>2、异步逻辑散落在各个action中，难以进行统一管理</p><p>因此，出现了redux-saga更强大的异步管理方案，可以代替redux-thunk使用。其特点如下：</p><p>1、使用generator的方式实现，更加符合同步代码的风格；</p><p>2、统一监听action，当命中action时，执行对应的saga任务，并且支持各个saga之间的互相调用，使得异步代码更方便统一管理。</p><h2 id="react-router"><a href="#react-router" class="headerlink" title="react-router"></a>react-router</h2><p>react-router中奉⾏⼀切皆组件的思想，路由器-Router、链接-Link、路由-Route、独占-Switch、重定向-Redirect都以组件形式存在 Route渲染优先级：children&gt;component&gt;render</p><p>与HashRouter对⽐： </p><ol><li>HashRouter最简单，不需要服务器端渲染，靠浏览器的#的来区分path就可以，BrowserRouter 需要服务器端对不同的URL返回不同的HTML，后端配置可参考。 </li><li>BrowserRouter使⽤HTML5历史API（ pushState，replaceState和popstate事件），让⻚⾯的UI 同步与URL。 </li><li>HashRouter不⽀持location.key和location.state，动态路由跳转需要通过?传递参数。 </li><li>Hash history 不需要服务器任何配置就可以运⾏，比较简单，在实际线上环境中一般用browserHistory，因为每⼀个 web 应⽤都应该渴望使⽤ browserHistory 。</li></ol><h2 id="react虚拟dom怎么执行的-树的遍历和diff"><a href="#react虚拟dom怎么执行的-树的遍历和diff" class="headerlink" title="react虚拟dom怎么执行的(树的遍历和diff)"></a>react虚拟dom怎么执行的(树的遍历和diff)</h2><p>把树形结构按照层级分解，只比较同级元素。</p><p>列表结构的每个单元添加唯一的 key 属性，方便比较。</p><p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p><p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p><p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p><h2 id="fiber架构的描述"><a href="#fiber架构的描述" class="headerlink" title="fiber架构的描述"></a>fiber架构的描述</h2><ul><li>旧: 浏览器渲染引擎单线程, 计算DOM树时锁住整个线程, 所有行为同步发生, 有效率问题, 期间react会一直占用浏览器主线程，如果组件层级比较深，相应的堆栈也会很深，长时间占用浏览器主线程, 任何其他的操作（包括用户的点击，鼠标移动等操作）都无法执行。</li><li>新: 重写底层算法逻辑, 引入fiber时间片, 异步渲染, react会在渲染一部分树后检查是否有更高优先级的任务需要处理(如用户操作或绘图), 处理完后再继续渲染, 并可以更新优先级, 以此管理渲染任务. 加入fiber的react将组件更新分为两个时期（phase 1 &amp;&amp; phase 2），render前的生命周期为phase1，render后的生命周期为phase2, 1可以打断, 2不能打断一次性更新. 三个will生命周期可能会重复执行, 尽量避免使用。</li></ul><h2 id="react16和15的虚拟dom有什么变化，"><a href="#react16和15的虚拟dom有什么变化，" class="headerlink" title="react16和15的虚拟dom有什么变化，"></a>react16和15的虚拟dom有什么变化，</h2><h2 id="fiber和虚拟dom的区别"><a href="#fiber和虚拟dom的区别" class="headerlink" title="fiber和虚拟dom的区别"></a>fiber和虚拟dom的区别</h2><p>fiber把整个虚拟dom树变成了一个链表指向，diff过程可以随时终端</p><p>元素 -&gt; 第一个子元素 -&gt; 兄弟元素 -&gt; 兄弟元素</p><h2 id="react事件系统和浏览事件系统有啥区别和关系"><a href="#react事件系统和浏览事件系统有啥区别和关系" class="headerlink" title="react事件系统和浏览事件系统有啥区别和关系"></a>react事件系统和浏览事件系统有啥区别和关系</h2><h2 id="dva-umi"><a href="#dva-umi" class="headerlink" title="dva+umi"></a>dva+umi</h2><h2 id="ant-design-antd-pro的源码"><a href="#ant-design-antd-pro的源码" class="headerlink" title="ant-design + antd-pro的源码"></a>ant-design + antd-pro的源码</h2>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;组件：class类组件和hooks函数组件开发&lt;/li&gt;
&lt;li&gt;context，redux数据状态管理&lt;/li&gt;
&lt;li&gt;虚拟dom，fiber架构&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>js基础面试题3</title>
    <link href="http://example.com/2021/02/28/js-base-interview3/"/>
    <id>http://example.com/2021/02/28/js-base-interview3/</id>
    <published>2021-02-28T11:29:52.925Z</published>
    <updated>2020-12-25T00:54:15.201Z</updated>
    
    <content type="html"><![CDATA[<ol><li>堆栈，垃圾回收机制，执行上下文，变量对象，作用域链，</li><li>作用域闭包，强大的闭包应用场景</li><li>深浅拷贝的原理和手写实现</li></ol><span id="more"></span><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><ol><li><p>基本类型：基本类型是保存在<strong>栈</strong>内存里面，有6种：Undefined、Null、Boolean、Number 、String和Symbol。因为这些类型在内存中分别占有固定大小的空间，通过按值来传递访问。</p></li><li><p>引用类型：引用类型是保存在<strong>堆</strong>内存中，像对象就是引用类型，对于引用类型，是通过按引用传递访问。按引用复制的值一个会随着一个的改变而改变。所以需要深浅拷贝，让两个值对彼此毫无影响。因为这种值的大小不固定，而内存地址大小的固定的。所以不能直接把值保存到栈内存中，而是把对象的内存地址保存在栈中，具体的值保存在堆中。当读取引用类型的变量时， 先从<strong>栈中读取内存地址</strong>， 然后再通过地址<strong>找到堆中的值</strong>。</p></li></ol><h2 id="v8引擎的垃圾回收机制"><a href="#v8引擎的垃圾回收机制" class="headerlink" title="v8引擎的垃圾回收机制"></a>v8引擎的垃圾回收机制</h2><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p><ol><li><p>V8引擎中所有的JS对象都是通过堆来进行内存分配的，包括初始分配和继续申请两个过程。</p><p> 当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。</p><p> 当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。</p></li><li><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的    对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</p></li><li><p>新生代：新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代，如临时变量、字符串等。新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会    执行 Scavenge 算法进行垃圾回收。当执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。</p></li><li><p>老生代：经历过多次垃圾回收的对象被称为老生代，如主控制器、服务器对象等。老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以在解决内存碎片的问题中引入了标记压缩法。</p></li><li><p>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回    收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完    一小步就让运行逻辑执行一会，就这样交替运行。</p></li></ol><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文主要包括变量对象，作用域链，this三部分。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><ol><li><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。因为不同执行上下文下的变量对象稍有不同，可以分为全局上下文下的变量对象和函数上下文下的变量对象。在函数上下文中，用活动对象(activation object, AO)来表示变量对象。</p></li><li><p>活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object ，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p></li><li><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。</p></li><li><p>总结：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 全局上下文的变量对象初始化是全局对象</span><br><span class="line">b. 函数上下文的变量对象初始化只包括 Arguments 对象</span><br><span class="line">c. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</span><br><span class="line">d. 在代码执行阶段，会再次修改变量对象的属性值</span><br></pre></td></tr></table></figure></li></ol><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><pre><code>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</code></pre><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><pre><code>this可以简单的理解为调用函数的对象，追根溯源的从 ECMASciript 规范解读 this 指向的话，属实复杂</code></pre><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p> JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>这两段代码都会打印’local scope’,但是区别在于执行上下文栈的变化是不一样的。</p><p>第一段代码的执行过程：</p><p>1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.全局上下文初始化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    VO: [<span class="built_in">global</span>],</span><br><span class="line">    Scope: [globalContext.VO],</span><br><span class="line">    <span class="built_in">this</span>: globalContext.VO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>4.checkscope 函数执行上下文初始化：</p><ol><li>复制函数 [[scope]] 属性创建作用域链，</li><li>用 arguments 创建活动对象，</li><li>初始化活动对象，即加入形参、函数声明、变量声明，</li><li>将活动对象压入 checkscope 作用域链顶端。</li></ol><p>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        scope: <span class="literal">undefined</span>,</span><br><span class="line">        f: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, globalContext.VO],</span><br><span class="line">    <span class="built_in">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    fContext,</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p><ol><li>复制函数 [[scope]] 属性创建作用域链</li><li>用 arguments 创建活动对象</li><li>初始化活动对象，即加入形参、函数声明、变量声明</li><li>将活动对象压入 f 作用域链顶端</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        <span class="built_in">arguments</span>: &#123;</span><br><span class="line">            length: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">    <span class="built_in">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p><p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>总之第一段代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>第二段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h3><pre><code>(1). 在js作用域环境中访问变量的过程是由内向外的，(2). 内部作用域可以获得当前作用域下的变量并且可以获得当前包含当前作用域的外层作用域下的变量，反之则不能，(3). 也就是说在外层作用域下无法获取内层作用域下的变量，同样在不同的函数作用域中也是不能相互访问彼此变量的。</code></pre><h3 id="2-闭包"><a href="#2-闭包" class="headerlink" title="2. 闭包"></a>2. 闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1).  一个函数内部也有限权访问另一个函数内部的变量，闭包的本质就是在一个函数内部创建另一个函数。</span><br><span class="line">(2).  简单来说就是函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</span><br><span class="line">(3).  在MDN里面闭包是说那些能够访问自由变量的函数，而自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量  的变 量，所以闭包 &#x3D; 函数 + 函数能够访问的自由变量。</span><br><span class="line">(4).  闭包的参数和变量不会被垃圾回收机制回收，所以可能会造成内存泄露，解决方法是可以在使用完变量后手动为它赋值为null。</span><br></pre></td></tr></table></figure><h3 id="3-经典闭包题"><a href="#3-经典闭包题" class="headerlink" title="3. 经典闭包题"></a>3. 经典闭包题</h3>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>   答案是都是 3, 其实这段代码相当于以下这样：</p>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  data[i] = fun;</span><br><span class="line">&#125;</span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">globalContext &#x3D; &#123;</span><br><span class="line">    VO: &#123;</span><br><span class="line">        data: [...],</span><br><span class="line">        i: 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data[0]Context &#x3D; &#123;</span><br><span class="line">    Scope: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   data[0]Context 的 AO 并没有 i 值，所以会从 globalContext.VO 中查找，i 为 3，所以打印的结果就是 3。</p><p>   data[1] 和 data[2] 也是一样的道理。</p><p>   使用闭包的方式如下： </p><h4 id="1-ES6中的let"><a href="#1-ES6中的let" class="headerlink" title="(1). ES6中的let"></a>(1). ES6中的let</h4><ul><li><p>```js<br>var data = [];<br>for (let i = 0; i &lt; 3; i++) {<br>  data[i] = function () {</p><pre><code>console.log(i);</code></pre><p>  };<br>}</p><p>data<a href="">0</a>;<br>data<a href="">1</a>;<br>data<a href="">2</a>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">####    (2). 立即执行函数</span><br><span class="line"></span><br><span class="line">-    &#96;&#96;&#96;js</span><br><span class="line">     for (var i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">         (function(num) &#123;</span><br><span class="line">             setTimeout(function() &#123;</span><br><span class="line">                 console.log(num);</span><br><span class="line">             &#125;, 1000);</span><br><span class="line">         &#125;)(i);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F; 0</span><br><span class="line">     &#x2F;&#x2F; 1</span><br><span class="line">     &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-返回一个匿名函数赋值"><a href="#3-返回一个匿名函数赋值" class="headerlink" title="(3). 返回一个匿名函数赋值"></a>(3). 返回一个匿名函数赋值</h4><ul><li><p>```js<br>var data = [];<br>for(var i = 0; i&lt;3; i++) {<br>  data[i] = (function(i) {</p><pre><code>return function() &#123;  console.log(i);&#125;</code></pre><p>  })(i)<br>}<br>data<a href="">0</a>;<br>data<a href="">1</a>;<br>data<a href="">2</a>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">​        当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  globalContext &#x3D; &#123;</span><br><span class="line">      VO: &#123;</span><br><span class="line">          data: [...],</span><br><span class="line">          i: 3</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>跟没改之前一模一样。</p><p>当执行 data[0] 函数的时候，data[0] 函数的作用域链发生了改变：</p></li><li><p>```<br>data[0]Context = {</p><pre><code>Scope: [AO, 匿名函数Context.AO globalContext.VO]</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  匿名函数执行上下文的AO为：</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  匿名函数Context &#x3D; &#123;</span><br><span class="line">      AO: &#123;</span><br><span class="line">          arguments: &#123;</span><br><span class="line">              0: 0,</span><br><span class="line">              length: 1</span><br><span class="line">          &#125;,</span><br><span class="line">          i: 0</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>data[0]Context 的 AO 并没有 i 值，所以会沿着作用域链从匿名函数 Context.AO 中查找，这时候就会找 i 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 i 的值(值为3)，所以打印的结果就是0。</p><p>data[1] 和 data[2] 是一样的道理。</p></li></ul><h2 id="深浅拷贝的原理和手写实现"><a href="#深浅拷贝的原理和手写实现" class="headerlink" title="深浅拷贝的原理和手写实现"></a>深浅拷贝的原理和手写实现</h2><h3 id="如何实现浅拷贝"><a href="#如何实现浅拷贝" class="headerlink" title="如何实现浅拷贝"></a>如何实现浅拷贝</h3><ol><li><code>Object.assign()</code></li><li>数组展开语法 <code>Spread</code></li><li><code>Array.prototype.slice()</code>、</li><li><code>Array.prototype.concat()</code></li></ol><h3 id="如何实现深拷贝"><a href="#如何实现深拷贝" class="headerlink" title="如何实现深拷贝"></a>如何实现深拷贝</h3><ol><li>写一个deepClone函数，递归遍历数组或者对象中嵌套的每一个子数组和子对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> obj == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = obj.constructor == <span class="built_in">Array</span> ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      result[i] = <span class="keyword">typeof</span> obj[i] == <span class="string">&quot;object&quot;</span> ? deepClone(obj[i]) : obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>JSON.parse(JSON.stringify(object))</li></ol><h3 id="深拷贝中需要注意的问题"><a href="#深拷贝中需要注意的问题" class="headerlink" title="深拷贝中需要注意的问题"></a>深拷贝中需要注意的问题</h3><pre><code>1. 会忽略 undefined2. 会忽略 symbol3. 不能序列化函数4. 不能解决循环引用的对象5. 不能正确处理new Date()6. 不能处理正则</code></pre><h3 id="如何解决循环引用的问题"><a href="#如何解决循环引用的问题" class="headerlink" title="如何解决循环引用的问题"></a>如何解决循环引用的问题</h3><p>解决方案很简单，其实就是循环检测，我们设置一个数组或者哈希表存储已拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出该值并返回即可。</p><h3 id="Lodash是如何实现深拷贝的"><a href="#Lodash是如何实现深拷贝的" class="headerlink" title="Lodash是如何实现深拷贝的"></a>Lodash是如何实现深拷贝的</h3><hr><p>参考：</p>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;堆栈，垃圾回收机制，执行上下文，变量对象，作用域链，&lt;/li&gt;
&lt;li&gt;作用域闭包，强大的闭包应用场景&lt;/li&gt;
&lt;li&gt;深浅拷贝的原理和手写实现&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>js基础面试题2</title>
    <link href="http://example.com/2021/02/28/js-base-interview2/"/>
    <id>http://example.com/2021/02/28/js-base-interview2/</id>
    <published>2021-02-28T11:29:52.920Z</published>
    <updated>2020-12-25T00:54:15.196Z</updated>
    
    <content type="html"><![CDATA[<ol><li>js的模块化</li><li>事件执行机制，event-loop，发布订阅，事件委托，宏任务微任务</li><li>防抖节流，函数柯里化，数组扁平化，promise异步，generator，sleep函数</li></ol><span id="more"></span><h2 id="js的模块化"><a href="#js的模块化" class="headerlink" title="js的模块化"></a>js的模块化</h2><ol><li>模块化发展历史</li></ol><ul><li><p>第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p></li><li><p>第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p></li><li><p>第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p></li><li><p>第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</p></li></ul><ol><li>AMD 和 CMD 规范的具体区别？<br>第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。<br>第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句 的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</li></ol><h2 id="手写一个防抖"><a href="#手写一个防抖" class="headerlink" title="手写一个防抖"></a>手写一个防抖</h2><p>效果: 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定时间到来之前，又触发了事件，就重新开始延时。也就是说当一个用户一直触发这个函数，且每次触发函数的间隔小于既定时间，那么防抖的情况下只会执行一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, time, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(immediate) &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      immediate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.butn&#x27;</span>).onclick = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;- debounce -&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手写一个节流"><a href="#手写一个节流" class="headerlink" title="手写一个节流"></a>手写一个节流</h2><p>当持续触发事件时，保证在一定时间内只调用一次事件处理函数，意思就是说，假设一个用户一直触发这个函数，且每次触发小于既定值，函数节流会每隔这个时间调用一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(immediate) &#123;</span><br><span class="line">      func.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      immediate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">if</span>(current - lastTime &gt; wait) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      lastTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;- throttle - &#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总之，防抖是将多次执行变为最后一次执行，节流是将多次执行变为每隔一段时间执行</p><h2 id="手写实现函数柯里化"><a href="#手写实现函数柯里化" class="headerlink" title="手写实现函数柯里化"></a>手写实现函数柯里化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = fn.length;</span><br><span class="line">  <span class="keyword">var</span> args = args || [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">if</span>(newArr.length &lt; length)&#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, newArr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, newArr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a*b*c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn);</span><br><span class="line">multi(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line">multi(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">multi(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">multi(<span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手写一个数组扁平化"><a href="#手写一个数组扁平化" class="headerlink" title="手写一个数组扁平化"></a>手写一个数组扁平化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure><h2 id="for-in-和-for-of的区别"><a href="#for-in-和-for-of的区别" class="headerlink" title="for in 和 for of的区别"></a>for in 和 for of的区别</h2><ol><li><p>for in遍历数组会遍历到数组原型上的属性和方法, 更适合遍历对象</p></li><li><p>forEach不支持break, continue, return等</p></li><li><p>使用for of可以成功遍历数组的值, 而不是索引, 不会遍历原型</p></li><li><p>for in 可以遍历到myObject的原型方法method,</p><p>如果不需要遍历原型方法和属性的话，hasOwnPropery方法可以判断某属性是否是该对象的实例属性</p></li></ol><h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><ol><li><p>优点: 解决回调地狱, 对异步任务写法更标准化与简洁化</p></li><li><p>缺点: </p><p>​    a. 无法取消Promise，一旦新建它就会立即执行，无法中途取消;     </p><p>​    b. 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部; </p><p>​    c. 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成).</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.status = <span class="string">&quot;pending&quot;</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.reason = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.value = value;</span><br><span class="line">      self.status = <span class="string">&quot;resolved&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status == <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      self.reason = value;</span><br><span class="line">      self.status = <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title">constructor</span>(<span class="params">resolve, reject</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFullfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">switch</span> (self.status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;resolved&quot;</span>:</span><br><span class="line">      onFullfilled(self.value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;rejected&quot;</span>:</span><br><span class="line">      onRejected(self.reason);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> myPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseList.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([]);</span><br><span class="line">    <span class="keyword">let</span> result = [],</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    promiseList.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise).then(</span><br><span class="line">        (value) =&gt; &#123;</span><br><span class="line">          result[index] = value;</span><br><span class="line">          <span class="keyword">if</span> (++count === promiseList.length) resolve(result);</span><br><span class="line">        &#125;,</span><br><span class="line">        (reason) =&gt; reject(reason)</span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="built_in">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="手写实现sleep函数"><a href="#手写实现sleep函数" class="headerlink" title="手写实现sleep函数"></a>手写实现sleep函数</h2><p>这种实现方式是利用一个伪死循环阻塞主线程。因为JS是单线程的。<br>所以通过这种方式可以实现真正意义上的sleep()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span><br><span class="line">  <span class="keyword">while</span> ((<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - start &lt; delay) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">  sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Generator，async和await："><a href="#Generator，async和await：" class="headerlink" title="Generator，async和await："></a>Generator，async和await：</h2><ol><li><p>Generator函数的语法糖，将*改成async，将yield换成await。</p></li><li><p>是对Generator函数的改进, 返回promise。</p></li><li><p>异步写法同步化，遇到await先返回，执行完异步再执行接下来的.</p></li><li><p>内置执行器, 无需next()</p></li></ol><h2 id="js事件执行机制，Event-Loop"><a href="#js事件执行机制，Event-Loop" class="headerlink" title="js事件执行机制，Event Loop"></a>js事件执行机制，Event Loop</h2><h3 id="如何实现一个事件的发布订阅"><a href="#如何实现一个事件的发布订阅" class="headerlink" title="如何实现一个事件的发布订阅"></a>如何实现一个事件的发布订阅</h3><p>实现: 发布者管理订阅者队列, 并有新消息推送功能. 订阅者仅关注更新就行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  listeners = &#123;&#125;;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">name,fn</span>)</span> &#123;</span><br><span class="line">    (<span class="built_in">this</span>.listeners[name] || (<span class="built_in">this</span>.listeners[name] = [])).push(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">name,fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tem = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.removeListener(name, fn)</span><br><span class="line">      fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    fn.fn = tem</span><br><span class="line">    <span class="built_in">this</span>.on(name, tem)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">name,fn</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.listeners[name]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.listeners[name] = <span class="built_in">this</span>.listeners[name].filter(<span class="function"><span class="params">listener</span>=&gt;</span> (</span><br><span class="line">        listener!==fn &amp;&amp; listener!==fn.fn</span><br><span class="line">      ))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">name, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.listeners[name]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.listeners[name].forEach(<span class="function"><span class="params">fn</span>=&gt;</span> &#123;</span><br><span class="line">        fn.call(<span class="built_in">this</span>, ...args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> eventEmitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">eventEmitter.on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click 1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">eventEmitter.on(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;click 2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// eventEmitter.off(&#x27;click&#x27;)</span></span><br><span class="line">eventEmitter.emit(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">eventEmitter.once(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line"><span class="comment">// console.log(eventEmitter);</span></span><br></pre></td></tr></table></figure><h3 id="事件循环机制event-loop"><a href="#事件循环机制event-loop" class="headerlink" title="事件循环机制event-loop"></a>事件循环机制event-loop</h3><p> <img src="http://yangwenxu.cn/assets/images/event-loop2.png" alt="图片" style="zoom: 50%;" /></p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入<code>Event Table</code>并注册函数。</li><li>当指定的事情完成时，<code>Event Table</code>会将这个函数移入<code>Event Queue</code>。</li><li>主线程内的任务执行完毕为空，会去<code>Event Queue</code>读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，就是常说的<code>Event Loop</code>(事件循环)。</li></ul><p>​     js引擎存在<code>monitoring process</code>进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去<code>Event Queue</code>那里检查是否有      等待被调用的函数。这就是js运行的整体流程</p><h3 id="宏认为和微任务"><a href="#宏认为和微任务" class="headerlink" title="宏认为和微任务"></a>宏认为和微任务</h3><p>  macro task:   <strong>setTimeout、MessageChannel、postMessage、setImmediate</strong></p><p>  micro task:  有 <strong>MutationObsever 和 Promise.then</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>首先js 是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</li><li>在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</li><li>当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</li><li>任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</li><li>当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</li></ol><h3 id="经典题型"><a href="#经典题型" class="headerlink" title="经典题型"></a>经典题型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>第一轮：主线程开始执行，遇到setTimeout，将setTimeout的回调函数丢到宏任务队列中，在往下执行new Promise立即执行，输出2，then的回调函数丢到微任务队列中，再继续执行，遇到process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出5，当所    有同步任务执行完成后看有没有可以执行的微任务，发现有then函数和nextTick两个微任务，先执行哪个呢？process.nextTick指定的异    步任务总是发生在所有异步任务之前，因此先执行process.nextTick输出4然后执行then函数输出3，第一轮执行结束。</p><p>第二轮：从宏任务队列开始，发现setTimeout回调，输出1执行完毕，因此结果是25431</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托 本质上是利用了浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到 目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件代理。</p><p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理我们还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><p>当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上，这就是事件传播，有时间捕捉window——&gt; document——&gt; html——&gt; body -—-&gt;目标元素event.target，事件目标，事件冒泡</p>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;js的模块化&lt;/li&gt;
&lt;li&gt;事件执行机制，event-loop，发布订阅，事件委托，宏任务微任务&lt;/li&gt;
&lt;li&gt;防抖节流，函数柯里化，数组扁平化，promise异步，generator，sleep函数&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>web前端面试</title>
    <link href="http://example.com/2020/11/19/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2020/11/19/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</id>
    <published>2020-11-19T07:45:33.000Z</published>
    <updated>2020-12-25T00:54:15.216Z</updated>
    
    <content type="html"><![CDATA[<p>任何好学的技能，都不是那么值钱。<br>全情投入，专注极致，刻意练习，守正出奇，未闻花名，愿等花开<br>以能造出什么样的轮子，来衡量学习的效果</p><span id="more"></span><h2 id="css基础"><a href="#css基础" class="headerlink" title="css基础"></a>css基础</h2><ol><li><p>行内元素和块状元素</p></li><li><p>position</p></li><li><p>盒子模型</p></li><li><p>高度塌陷，清除浮动</p></li><li><p>BFC块级格式化上下文</p></li><li><p>实现一个水平垂直居中</p></li><li><p>层叠上下文</p></li><li><p>三栏布局</p></li><li><p>flex布局</p><ol><li>flex布局的相关用法</li><li>如何用flex实现九宫格布局</li><li>flex:1指的是什么</li><li>flex容器container的相关属性</li><li>flex项目item的相关属性</li></ol></li><li><p>1px</p><ol><li>移动端1px问题是怎么解决的</li><li>介绍一下rem方案和vw方案，分别有什么优点和缺点</li><li>rem方案的font-size是挂在哪的</li><li>rem方案时移动端字体是怎么处理的</li></ol></li><li><p>移动端适配</p></li><li><p>重绘回流，如何避免</p></li><li><p>预处理语言sass和less</p></li></ol><h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><ol><li><p>执行上下文，作用域链，闭包</p><ol><li>JavaScript的执行上下文</li><li>JavaScript的作用域链</li><li>JavaScript强大的闭包应用场景</li></ol></li><li><p>垃圾回收机制</p><ol><li>新生代</li><li>老生代</li><li>标记清除</li><li>标记压缩</li><li>引用计数</li></ol></li><li><p>this, call, apply,bind</p><ol><li>变幻莫测的this指向</li><li>如何改变this指向</li><li>call，apply，bind的区别</li><li>如何实现call和apply</li><li>手写一个bind</li></ol></li><li><p>原型，继承</p><ol><li>原型和原型链</li><li>实现一个继承，</li></ol></li><li><p>promise及异步</p><ol><li>手写并实现一个promise</li><li>async 和await</li><li>实现一个sheep函数</li></ol></li><li><p>深浅拷贝</p><ol><li>介绍js的深浅拷贝</li><li>如何实现深浅拷贝</li><li>实现深拷贝需要注意哪些问题</li><li>如何解决循环引用的问题</li></ol></li><li><p>事件机制，Event Loop</p><ol><li>如何实现一个事件的发布订阅</li><li>事件循环机制</li><li>宏认为和微任务的区别</li></ol></li><li><p>函数式编程</p><ol><li>函数柯里化</li><li>数组扁平化</li><li>防抖与节流</li><li>高阶函数</li></ol></li><li><p>service worker和web worker</p></li><li><p>ES6的语法</p></li></ol><h2 id="vue框架使用和源码原理"><a href="#vue框架使用和源码原理" class="headerlink" title="vue框架使用和源码原理"></a>vue框架使用和源码原理</h2><ol><li><p>生命周期</p></li><li><p>组件中 data 为什么是一个函数？</p></li><li><p>computed和watch的区别</p></li><li><p>v-if,v-show,v-html的原理</p></li><li><p>v-if和v-for的优先级</p></li><li><p>双向数据绑定</p></li><li><p>响应式原理</p></li><li><p>vm.$set()实现原理</p></li><li><p>Vue 的渲染过程</p></li><li><p>vue中key的作用</p></li><li><p>虚拟dom，diff算法</p></li><li><p>nextTick的原理</p></li><li><p>组件通信</p></li><li><p>vuex状态管理</p></li><li><p>vue-router路由实现</p></li><li><p>keep-alive 的实现原理和缓存策略</p></li><li><p>vue3的改动</p></li><li><p>vue和react的区别</p></li><li><p>vuejs的优化策略</p></li></ol><h2 id="react框架使用与源码原理"><a href="#react框架使用与源码原理" class="headerlink" title="react框架使用与源码原理"></a>react框架使用与源码原理</h2><ol><li><p>react虚拟dom怎么执行的(树的遍历和diff)</p></li><li><p>react16和15的虚拟dom架构有什么变化，fiber架构的描述</p><p> fiber把整个虚拟dom树变成了一个链表指向，diff过程可以随时终端</p><p> 元素 -&gt; 第一个子元素 -&gt; 兄弟元素 -&gt; 兄弟元素</p></li><li><p>fiber和虚拟dom的区别</p></li><li><p>react16的hooks到底是怎么执行的，react事件系统和浏览事件系统有啥区别和关系</p></li><li><p>react-router原理</p></li><li><p>react怎么实现ssr框架</p></li><li><p>ant-design + antd-pro的源码</p></li><li><p>redux生态 （redux react-redux, redux-sage dva, umi)</p></li></ol><h2 id="浏览器网络"><a href="#浏览器网络" class="headerlink" title="浏览器网络"></a>浏览器网络</h2><ol><li><p>重绘与回流</p></li><li><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</p></li><li><p>cookie与session，localStorage 与 sessionStorage</p></li><li><p>跨域，预检请求，同源策略</p></li><li><p>浏览器的缓存机制</p></li><li><p>http和https</p></li><li><p>http头部，状态码</p></li><li><p>https的加密算法</p></li><li><p>http1.0，http1.1, http2.0, http3.0</p></li><li><p>get请求与post请求</p></li><li><p>正向代理和反向代理</p></li><li><p>tcp连接的三次握手与四次挥手</p></li></ol><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>代码执行更快</li><li>网络传输更快</li><li>文件加载更快</li><li>webpack性能优化</li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li>单例模式</li><li>策略模式</li><li>代理模式</li><li>发布订阅模式(观察者模式)</li></ol><h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><ol><li>斐波拉契数列，爬楼梯问题，递归</li><li>排序算法，冒泡排序，选择排序，快速排序</li><li>二叉树，二叉树的查找与遍历</li><li>贪心算法： 局部最优解法，经典背包问题</li><li>分治算法：分而治之</li><li>动态规划：每个状态都是过去历史的一个总结</li><li>回溯法：现原先选择不优时，退回重新选择</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何好学的技能，都不是那么值钱。&lt;br&gt;全情投入，专注极致，刻意练习，守正出奇，未闻花名，愿等花开&lt;br&gt;以能造出什么样的轮子，来衡量学习的效果&lt;/p&gt;</summary>
    
    
    
    <category term="interview" scheme="http://example.com/categories/interview/"/>
    
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>koa源码原理解析</title>
    <link href="http://example.com/2020/09/22/koa%E6%BA%90%E7%A0%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2020/09/22/koa%E6%BA%90%E7%A0%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</id>
    <published>2020-09-22T12:07:17.000Z</published>
    <updated>2020-09-22T13:55:01.784Z</updated>
    
    <content type="html"><![CDATA[<p>一个语言的成熟需要时间的积累，,koa是一个新的web框架，致⼒于成为 web 应⽤和 API 开发领域中的⼀个更⼩、更富有表现⼒、更健壮的基⽯。</p><span id="more"></span><h2 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h2><ul><li><p>概述：koa是一个新的web框架，致⼒于成为 web 应⽤和 API 开发领域中的⼀个更⼩、更富有<br>  表现⼒、更健壮的基⽯。</p><p>koa是Express的下一代基于nodejs的web框架</p><p>koa2完全使用promise并配合async来实现异步</p></li><li><p>特点：</p><ol><li>轻量，无捆绑</li><li>中间件架构</li><li>优雅的API设计</li><li>增强的错误处理</li></ol></li><li><p>安装：npm i koa -S</p></li><li><p>中间件机制，请求，响应处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;  </span><br><span class="line">    ctx.body = [</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> router = &#123;&#125;</span><br><span class="line">router[<span class="string">&#x27;/html&#x27;</span>] = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">    ctx.type = <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line">    ctx.body = <span class="string">`&lt;b&gt;我的名字是:<span class="subst">$&#123;ctx.body[<span class="number">0</span>].name&#125;</span>&lt;/b&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 搞个⼩路由</span></span><br><span class="line"><span class="keyword">const</span> router = &#123;&#125;</span><br><span class="line">router[<span class="string">&#x27;/html&#x27;</span>] = <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line"> ctx.type = <span class="string">&#x27;text/html;charset=utf-8&#x27;</span></span><br><span class="line"> ctx.body = <span class="string">`&lt;b&gt;我的名字是:<span class="subst">$&#123;ctx.body[<span class="number">0</span>].name&#125;</span>&lt;/b&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fun = router[ctx.url]</span><br><span class="line">fun &amp;&amp; fun(ctx)</span><br></pre></td></tr></table></figure></li><li><p>koa中间件机制  </p><p>​      Koa中间件机制就是函数式 组合概念 Compose的概念，将 ⼀组需要顺序执⾏的 函数复合为⼀个函数，外层函数的参数实际是内层函数的返回值。洋葱圈模型可以形象表示这种机 制，是源码中的精髓和难点。</p></li><li><p>常见的中间件操作</p><ul><li><p>静态服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)(__dirname + <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)()</span><br><span class="line">router.get(<span class="string">&#x27;/string&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"> ctx.body = <span class="string">&#x27;koa2 string&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">router.get(<span class="string">&#x27;/json&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">     ctx.body = &#123;</span><br><span class="line">     title: <span class="string">&#x27;koa2 json&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.use(router.routes())</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>日志</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx,next) =&gt; &#123;</span><br><span class="line">     <span class="keyword">const</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`start: <span class="subst">$&#123;ctx.url&#125;</span>`</span>);</span><br><span class="line">     <span class="keyword">await</span> next();</span><br><span class="line">     <span class="keyword">const</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`请求<span class="subst">$&#123;ctx.url&#125;</span>, 耗时<span class="subst">$&#123;<span class="built_in">parseInt</span>(end-start)&#125;</span>ms`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="koa原理："><a href="#koa原理：" class="headerlink" title="koa原理："></a>koa原理：</h2><ul><li><p>​    ⼀个基于nodejs的⼊⻔级http服务，类似下⾯代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>)=&gt;</span>&#123;</span><br><span class="line">     res.writeHead(<span class="number">200</span>)</span><br><span class="line">     res.end(<span class="string">&#x27;hi kaikeba&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;监听端⼝3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>​    koa的目标是用简单化，流程化，模块化的方式实现回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建kkb.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KKB</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.callback(req, res);</span><br><span class="line">         &#125;);</span><br><span class="line">         server.listen(...args);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">use</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.callback = callback;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = KKB;</span><br><span class="line"><span class="comment">// 调⽤，index.js</span></span><br><span class="line"><span class="keyword">const</span> KKB = <span class="built_in">require</span>(<span class="string">&quot;./kkb&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> KKB();</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;<span class="string">` `</span></span><br><span class="line">res.writeHead(<span class="number">200</span>);</span><br><span class="line"> res.end(<span class="string">&quot;hi kaikeba&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;监听端⼝3000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>   ⽬前为⽌，KKB只是个⻢甲，要真正实现⽬标还需要引⼊上下⽂（context）和中间件机制 （middleware）</p></li></ul><h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><ul><li><p>koa为了能够简化API，引⼊上下⽂context概念，将原始请求对象req和响应对象res封装并挂载到 context上，并且在context上设置getter和setter，从⽽简化操作。</p></li><li><p>知识储备：getter/setter方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码，test-getter-setter.js</span></span><br><span class="line"><span class="keyword">const</span> kaikeba = &#123;</span><br><span class="line"> info:&#123; <span class="attr">name</span>: <span class="string">&#x27;开课吧&#x27;</span>, <span class="attr">desc</span>: <span class="string">&#x27;开课吧真不错&#x27;</span> &#125;,</span><br><span class="line"> <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.info.name</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="keyword">set</span> <span class="title">name</span>(<span class="params">val</span>)&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;new name is&#x27;</span> + val)</span><br><span class="line"> <span class="built_in">this</span>.info.name = val</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kaikeba.name)</span><br><span class="line">kaikeba.name = <span class="string">&#x27;kaikeba&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(kaikeba.name)</span><br></pre></td></tr></table></figure></li><li><p>封装request，response和context</p><p><a href="https://github.com/koajs/koa/blob/master/lib/response.js">https://github.com/koajs/koa/blob/master/lib/response.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="keyword">get</span> <span class="title">url</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.req.url;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">get</span> <span class="title">method</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.req.method.toLowerCase()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// response.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="keyword">get</span> <span class="title">body</span>() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>._body;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="keyword">set</span> <span class="title">body</span>(<span class="params">val</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>._body = val;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="keyword">get</span> <span class="title">url</span>() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.request.url;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="keyword">get</span> <span class="title">body</span>() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.response.body;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="keyword">set</span> <span class="title">body</span>(<span class="params">val</span>) &#123;</span><br><span class="line">     <span class="built_in">this</span>.response.body = val;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="keyword">get</span> <span class="title">method</span>() &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.request.method</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kkb.js</span></span><br><span class="line"><span class="comment">// 导⼊这三个类</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">&quot;./context&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&quot;./request&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">&quot;./response&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KKB</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">             <span class="comment">// 创建上下⽂</span></span><br><span class="line">             <span class="keyword">let</span> ctx = <span class="built_in">this</span>.createContext(req, res);</span><br><span class="line"></span><br><span class="line">             <span class="built_in">this</span>.callback(ctx)</span><br><span class="line">             <span class="comment">// 响应</span></span><br><span class="line">             res.end(ctx.body);</span><br><span class="line">         &#125;);</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 构建上下⽂, 把res和req都挂载到ctx之上，并且在ctx.req和ctx.request.req同时保存</span></span><br><span class="line">     <span class="function"><span class="title">createContext</span>(<span class="params">req, res</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">const</span> ctx = <span class="built_in">Object</span>.create(context);</span><br><span class="line">         ctx.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">         ctx.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">         ctx.req = ctx.request.req = req;</span><br><span class="line">         ctx.res = ctx.response.res = res;</span><br><span class="line">         <span class="keyword">return</span> ctx;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ul><li><p>Koa中间件机制：Koa中间件机制就是函数组合的概念，将⼀组需要顺序执⾏的函数复合为⼀个函 数，外层函数的参数实际是内层函数的返回值。洋葱圈模型可以形象表示这种机制，是源码中的精 髓和难点。</p></li><li><p>异步中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middlewares</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">         <span class="comment">// 执⾏第0个</span></span><br><span class="line">         <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">let</span> fn = middlewares[i];</span><br><span class="line">             <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">                 fn(<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                     <span class="comment">// promise完成后，再执⾏下⼀个</span></span><br><span class="line">                     <span class="keyword">return</span> dispatch(i + <span class="number">1</span>);</span><br><span class="line">                 &#125;)</span><br><span class="line">             );</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;fn1&quot;</span>);</span><br><span class="line">     <span class="keyword">await</span> next();</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;end fn1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;fn2&quot;</span>);</span><br><span class="line">     <span class="keyword">await</span> delay();</span><br><span class="line">     <span class="keyword">await</span> next();</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;end fn2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;fn3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line"> vnm        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            reslove();</span><br><span class="line">         &#125;, <span class="number">2000</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> middlewares = [fn1, fn2, fn3];</span><br><span class="line"><span class="keyword">const</span> finalFn = compose(middlewares);</span><br><span class="line">finalFn();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>compose用在koa中，kkb.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">&quot;./context&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&quot;./request&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">&quot;./response&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KKB</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 初始化中间件数组</span></span><br><span class="line">     <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.middlewares = [];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">listen</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">const</span> server = http.createServer(<span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">             <span class="keyword">const</span> ctx = <span class="built_in">this</span>.createContext(req, res);</span><br><span class="line">             <span class="comment">// 中间件合成</span></span><br><span class="line">             <span class="keyword">const</span> fn = <span class="built_in">this</span>.compose(<span class="built_in">this</span>.middlewares);</span><br><span class="line">             <span class="comment">// 执⾏合成函数并传⼊上下⽂</span></span><br><span class="line">             <span class="keyword">await</span> fn(ctx);</span><br><span class="line">             res.end(ctx.body);</span><br><span class="line">         &#125;);</span><br><span class="line">         server.listen(...args);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">use</span>(<span class="params">middleware</span>)</span> &#123;</span><br><span class="line">         <span class="comment">// 将中间件加到数组⾥</span></span><br><span class="line">         <span class="built_in">this</span>.middlewares.push(middleware);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 合成函数</span></span><br><span class="line">     <span class="function"><span class="title">compose</span>(<span class="params">middlewares</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx</span>) </span>&#123; <span class="comment">// 传⼊上下⽂</span></span><br><span class="line">             <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">             <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">                 <span class="keyword">let</span> fn = middlewares[i];</span><br><span class="line">                 <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">                    fn(ctx, <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;<span class="comment">// 将上下⽂传⼊中间件，mid(ctx,next)</span></span><br><span class="line">                        <span class="keyword">return</span> dispatch(i + <span class="number">1</span>);</span><br><span class="line">                    &#125;)</span><br><span class="line">                 );</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">createContext</span>(<span class="params">req, res</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> ctx = <span class="built_in">Object</span>.create(context);</span><br><span class="line">         ctx.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">         ctx.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">         ctx.req = ctx.request.req = req;</span><br><span class="line">         ctx.res = ctx.response.res = res;</span><br><span class="line">         <span class="keyword">return</span> ctx;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = KKB;</span><br></pre></td></tr></table></figure><p>使用， app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> delay = <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(),<span class="number">2000</span>));</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">     ctx.body = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">     <span class="keyword">await</span> next();</span><br><span class="line">     ctx.body += <span class="string">&quot;5&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">     ctx.body += <span class="string">&quot;2&quot;</span>;</span><br><span class="line">     <span class="keyword">await</span> delay();</span><br><span class="line">     <span class="keyword">await</span> next();</span><br><span class="line">     ctx.body += <span class="string">&quot;4&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line"> ctx.body += <span class="string">&quot;3&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>koa-compose的<a href="https://github.com/koajs/compose/blob/master/index.js">源码</a></p></li></ul><h2 id="常见koa中间件的实现"><a href="#常见koa中间件的实现" class="headerlink" title="常见koa中间件的实现"></a>常见koa中间件的实现</h2><ul><li><p>koa中间件的规范</p><ul><li><p>一个是async函数</p></li><li><p>接收ctx和next两个参数</p></li><li><p>任务结束需要执行next</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mid = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">     <span class="comment">// 来到中间件，洋葱圈左边</span></span><br><span class="line">     next() <span class="comment">// 进⼊其他中间件</span></span><br><span class="line">     <span class="comment">// 再次来到中间件，洋葱圈右边</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>中间件常见任务</p><ul><li>请求拦截</li><li>路由</li><li>日志</li><li>静态文件服务</li></ul></li><li><p>路由router可能的用法</p></li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;./kkb&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line">router.get(<span class="string">&#x27;/index&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;index page&#x27;</span>; &#125;);</span><br><span class="line">router.get(<span class="string">&#x27;/post&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;post page&#x27;</span>; &#125;);</span><br><span class="line">router.get(<span class="string">&#x27;/list&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;list page&#x27;</span>; &#125;);</span><br><span class="line">router.post(<span class="string">&#x27;/index&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;post page&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// 路由实例输出⽗中间件 router.routes()</span></span><br><span class="line">app.use(router.routes());</span><br></pre></td></tr></table></figure><p>  routes()的返回值是⼀个中间件，由于需要⽤到method，所以需要挂载method到ctx之上。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="comment">// add...</span></span><br><span class="line">     <span class="keyword">get</span> <span class="title">method</span>()&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.req.method.toLowerCase()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="comment">// add...</span></span><br><span class="line">     <span class="keyword">get</span> <span class="title">method</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.request.method</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stack = [];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="title">register</span>(<span class="params">path, methods, middleware</span>)</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> route = &#123;path, methods, middleware&#125;</span><br><span class="line">         <span class="built_in">this</span>.stack.push(route);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 现在只⽀持get和post，其他的同理</span></span><br><span class="line">     <span class="function"><span class="title">get</span>(<span class="params">path,middleware</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.register(path, <span class="string">&#x27;get&#x27;</span>, middleware);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">post</span>(<span class="params">path,middleware</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.register(path, <span class="string">&#x27;post&#x27;</span>, middleware);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="title">routes</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> stock = <span class="built_in">this</span>.stack;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">let</span> currentPath = ctx.url;</span><br><span class="line">             <span class="keyword">let</span> route;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; stock.length; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> item = stock[i];</span><br><span class="line">                 <span class="keyword">if</span> (currentPath === item.path &amp;&amp; item.methods.indexOf(ctx.method) &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                     <span class="comment">// 判断path和method</span></span><br><span class="line">                     route = item.middleware;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (<span class="keyword">typeof</span> route === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                 route(ctx, next);</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">await</span> next();</span><br><span class="line">         &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">module</span>.exports = Router;</span><br></pre></td></tr></table></figure><p>  使用：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;./kkb&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;./router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line">router.get(<span class="string">&#x27;/index&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;index,xx&#x27;</span>)</span><br><span class="line">     ctx.body = <span class="string">&#x27;index page&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">router.get(<span class="string">&#x27;/post&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;post page&#x27;</span>; &#125;);</span><br><span class="line">router.get(<span class="string">&#x27;/list&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;list page&#x27;</span>; &#125;);</span><br><span class="line">router.post(<span class="string">&#x27;/index&#x27;</span>, <span class="keyword">async</span> ctx =&gt; &#123; ctx.body = <span class="string">&#x27;post page&#x27;</span>; &#125;);</span><br><span class="line"><span class="comment">// 路由实例输出⽗中间件 router.routes()</span></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;server runing on port 9092&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>静态文件服务koa-static</p><ul><li><p>配置绝对资源目录地址，默认为static</p></li><li><p>获取文件或者目录信息</p></li><li><p>静态文件读取</p><p>返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">dirPath = <span class="string">&quot;./public&quot;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.url.indexOf(<span class="string">&quot;/public&quot;</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// public开头 读取文件</span></span><br><span class="line">      <span class="keyword">const</span> url = path.resolve(__dirname, dirPath);</span><br><span class="line">      <span class="keyword">const</span> fileBaseName = path.basename(url);</span><br><span class="line">      <span class="keyword">const</span> filepath = url + ctx.url.replace(<span class="string">&quot;/public&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(filepath);</span><br><span class="line">      <span class="comment">// console.log(ctx.url,url, filepath, fileBaseName)</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        stats = fs.statSync(filepath);</span><br><span class="line">        <span class="keyword">if</span> (stats.isDirectory()) &#123;</span><br><span class="line">          <span class="keyword">const</span> dir = fs.readdirSync(filepath);</span><br><span class="line">          <span class="comment">// const</span></span><br><span class="line">          <span class="keyword">const</span> ret = [<span class="string">&#x27;&lt;div style=&quot;padding-left:20px&quot;&gt;&#x27;</span>];</span><br><span class="line">          dir.forEach(<span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(filename);</span><br><span class="line">            <span class="comment">// 简单认为不带小数点的格式，就是文件夹，实际应该用statSync</span></span><br><span class="line">            <span class="keyword">if</span> (filename.indexOf(<span class="string">&quot;.&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">              ret.push(</span><br><span class="line">                <span class="string">`&lt;p&gt;&lt;a style=&quot;color:black&quot; href=&quot;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                  ctx.url</span></span></span><br><span class="line"><span class="string"><span class="subst">                &#125;</span>/<span class="subst">$&#123;filename&#125;</span>&quot;&gt;<span class="subst">$&#123;filename&#125;</span>&lt;/a&gt;&lt;/p&gt;`</span></span><br><span class="line">              );</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 文件</span></span><br><span class="line">              ret.push(</span><br><span class="line">                <span class="string">`&lt;p&gt;&lt;a href=&quot;<span class="subst">$&#123;ctx.url&#125;</span>/<span class="subst">$&#123;filename&#125;</span>&quot;&gt;<span class="subst">$&#123;filename&#125;</span>&lt;/a&gt;&lt;/p&gt;`</span></span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          ret.push(<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">          ctx.body = ret.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> content = fs.readFileSync(filepath);</span><br><span class="line">          ctx.body = content;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 报错了 文件不存在</span></span><br><span class="line">        ctx.body = <span class="string">&quot;404, not found&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则不是静态资源，直接去下一个中间件</span></span><br><span class="line">      <span class="keyword">await</span> next();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使⽤</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&#x27;./static&#x27;</span>)</span><br><span class="line">app.use(<span class="keyword">static</span>(__dirname + <span class="string">&#x27;/public&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>请求拦截：黑名单中存在的ip访问将被拒绝</p><p>​    请求拦截应用非常广泛，登录状态验证，cors头设置等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iptable.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; res, req &#125; = ctx;</span><br><span class="line">     <span class="keyword">const</span> blackList = [<span class="string">&#x27;127.0.0.1&#x27;</span>];</span><br><span class="line">     <span class="keyword">const</span> ip = getClientIP(req);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (blackList.includes(ip)) &#123;<span class="comment">//出现在⿊名单中将被拒绝</span></span><br><span class="line">         ctx.body = <span class="string">&quot;not allowed&quot;</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> next();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClientIP</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">         req.headers[<span class="string">&quot;x-forwarded-for&quot;</span>] || <span class="comment">// 判断是否有反向代理 IP</span></span><br><span class="line">         req.connection.remoteAddress || <span class="comment">// 判断 connection 的远程 IP</span></span><br><span class="line">         req.socket.remoteAddress || <span class="comment">// 判断后端的 socket 的 IP</span></span><br><span class="line">         req.connection.socket.remoteAddress</span><br><span class="line">     );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">&quot;./interceptor&quot;</span>));</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&quot;监听端⼝3000&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个语言的成熟需要时间的积累，,koa是一个新的web框架，致⼒于成为 web 应⽤和 API 开发领域中的⼀个更⼩、更富有表现⼒、更健壮的基⽯。&lt;/p&gt;</summary>
    
    
    
    
    <category term="node" scheme="http://example.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>vue组件化通信</title>
    <link href="http://example.com/2020/08/19/vue%E7%BB%84%E4%BB%B6%E5%8C%96%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2020/08/19/vue%E7%BB%84%E4%BB%B6%E5%8C%96%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-19T12:20:19.000Z</published>
    <updated>2020-08-19T12:39:14.695Z</updated>
    
    <content type="html"><![CDATA[<pre><code>平时在使用Vue框架的业务开发中，组件不仅仅要把模板的内容进行复用，更重要的是组件之间要进行通信。组件之间通信分为三种：父-子；子-父；跨级组件通信。下面，就组件间如何通信做一些总结。</code></pre><span id="more"></span><h2 id="1-父传子组件"><a href="#1-父传子组件" class="headerlink" title="1. 父传子组件"></a>1. 父传子组件</h2><pre><code>在组件中，使用选项props来声明需要从父级组件接受的数据，props的值可以是两种：一种是字符串数组，一种是对象。props中声明的数据与组件data函数return的主要区别在于props来自父级，而data中的组件是自己的数据，作用域是组件本身，这两种数据都可以在模板template及计算属性computed和方法methods中使用。如以下例子：</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 父组件 ParentComponent</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent-component&quot;</span>&gt;</span><br><span class="line">    &lt;h2&gt;这是一个父组件&lt;/h2&gt;</span><br><span class="line">    &lt;ChildComponent :parentMessage=<span class="string">&quot;parentMessage&quot;</span>/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> ChildComponent <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;ParentComponent&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">        parentMessage:<span class="string">&#x27;这是来自父组件的数据&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      ChildComponent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 子组件 ChildComponent</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;child-component&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;这是一个子组件&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;h3&gt;&#123;&#123;parentMessage&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: &quot;ChildComponent&quot;,</span></span><br><span class="line"><span class="string">    props:[&quot;parentMessage&quot;]</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">小结：父组件传递个子组件的数据可以写死，也可以用父级的动态数据用v-bind来绑定props的值。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 2. 子传父</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当子组件需要向父组件传递数据时，就要用到自定义事件，v-on指令除了监听DOM事件外，还可以用于组件间的自定义事件，</span></span><br><span class="line"><span class="string">Vue组件有一套类似与观察者模式的一套模式，子组件用$emit()来触发事件，父组件用$on()来监听子组件的事件。举个例子如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParentComponent 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;parent-component&quot;</span>&gt;</span><br><span class="line">    &lt;h2&gt;这是一个父组件total:&#123;&#123;total&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;ChildComponent :parentMessage=<span class="string">&quot;parentMessage&quot;</span> :total=<span class="string">&quot;total&quot;</span> @handleAdd10=<span class="string">&quot;getTotal&quot;</span>/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">import</span> ChildComponent <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;ParentComponent&quot;</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">        parentMessage:<span class="string">&#x27;这是来自父组件的数据&#x27;</span>,</span><br><span class="line">        total:<span class="number">10</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      ChildComponent</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      <span class="function"><span class="title">getTotal</span>(<span class="params">total</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.total=total;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;ParentComponent total:&#x27;</span>,total);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// ChildComponent 子组件</span></span><br><span class="line"><span class="string">&lt;template&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;child-component&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;h2&gt;这是一个子组件&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;h3&gt;&#123;&#123;parentMessage&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">  &lt;button @click=&quot;handleAdd10&quot;&gt;+10按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  export default &#123;</span></span><br><span class="line"><span class="string">    name: &quot;ChildComponent&quot;,</span></span><br><span class="line"><span class="string">    props:[&quot;parentMessage&quot;,&quot;total&quot;],</span></span><br><span class="line"><span class="string">    methods:&#123;</span></span><br><span class="line"><span class="string">      handleAdd10()&#123;</span></span><br><span class="line"><span class="string">        let total=this.total+10;</span></span><br><span class="line"><span class="string">        console.log(&#x27;ChildComponent $emit:&#x27;);</span></span><br><span class="line"><span class="string">        this.$emit(&#x27;handleAdd10&#x27;,total);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面例子中，子组件有一个按钮，实现加10的效果，子组件通过props项来接收父组件传入的total值，在改变total后，</span></span><br><span class="line"><span class="string">通过$emit把它传给父组件，父组件定义事件@handleAdd10方法，子组件$emit()方法第一个参数是自定义事件的名称，</span></span><br><span class="line"><span class="string">后面的参数是要传的数据，对应的父组件通过getTotal(total)来接收子组件传递的数据，由此子组件到父组件通信完成。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 3.表单子组件到父组件通过v-model来通信(语法糖)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParentComponent 改动如下</span></span><br><span class="line">**</span><br><span class="line">&lt;h2&gt;这是一个父组件total:&#123;&#123;total&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;ChildComponent :parentMessage=<span class="string">&quot;parentMessage&quot;</span> :total=<span class="string">&quot;total&quot;</span> @handleAdd10=<span class="string">&quot;getTotal&quot;</span>/&gt;</span><br><span class="line">&lt;InputComponent v-model=<span class="string">&quot;total&quot;</span>/&gt;</span><br><span class="line">**</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> InputComponent <span class="keyword">from</span> <span class="string">&#x27;./InputComponent&#x27;</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">**</span><br><span class="line"></span><br><span class="line"><span class="comment">// InputComponent 子组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> @input=<span class="string">&quot;updateValue($event)&quot;</span>&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">&quot;InputComponent&quot;</span>,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      <span class="function"><span class="title">updateValue</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>,evt.target.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>以上示例中：因为子组件的石建明是特殊的input，在使用组件的父级，可以通过v-model来绑定数据total，这种实现方式也可以称作语法糖，大大减少了父组件代码量。</code></pre><h2 id="3-兄弟组件"><a href="#3-兄弟组件" class="headerlink" title="3. 兄弟组件"></a>3. 兄弟组件</h2><h2 id="4-祖先后代provide-inject"><a href="#4-祖先后代provide-inject" class="headerlink" title="4. 祖先后代provide $ inject"></a>4. 祖先后代provide $ inject</h2><h2 id="5-dispatch"><a href="#5-dispatch" class="headerlink" title="5. dispatch"></a>5. dispatch</h2><h2 id="6-boardcast"><a href="#6-boardcast" class="headerlink" title="6. boardcast"></a>6. boardcast</h2><h2 id="7-全局挂载dispatch和boardcast"><a href="#7-全局挂载dispatch和boardcast" class="headerlink" title="7. 全局挂载dispatch和boardcast"></a>7. 全局挂载dispatch和boardcast</h2><h2 id="8-event-bus中央事件总线"><a href="#8-event-bus中央事件总线" class="headerlink" title="8. event-bus中央事件总线"></a>8. event-bus中央事件总线</h2><pre><code class="lang-javascript">// ParentComponent 父组件&lt;template&gt;  &lt;div class=&quot;parent-component&quot;&gt;    &#123;&#123;message&#125;&#125;    &lt;br&gt;    &lt;br&gt;    &lt;component-a/&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import Vue from &#39;vue&#39;  let bus=new Vue();  export default &#123;    name: &quot;ParentComponent&quot;,    data()&#123;      return&#123;        message:&#39;&#39;,      &#125;    &#125;,    components:&#123;      componentA:&#123;        template:&#39;&lt;button @click=&quot;handleClick&quot;&gt;传递事件&lt;/button&gt;&#39;,        methods:&#123;          handleClick()&#123;            bus.$emit(&#39;on-message&#39;,&#39;来自子组件component-a的内容&#39;)          &#125;        &#125;      &#125;    &#125;,    mounted()&#123;      bus.$on(&#39;on-message&#39;,(msg)=&gt;&#123;        this.message=msg;      &#125;);    &#125;  &#125;&lt;/script&gt;`</code></pre><pre><code>以上例子中：首先创建了一个bus的空Vue实例，里面没有任何内容，然后全局定义了组件component-a,，在父组件ParentChild的生命周期mounted钩子函数中监听来自bus的事件on-message。而在组件component-a中，点击按钮会通过bus把事件on-message发出去，父组件会接受来自bus的事件，改变message的值。这种方法巧妙轻量的实现了任何组件之间的通信，包括父子，兄弟，跨级组件。</code></pre><h2 id="9-vuex"><a href="#9-vuex" class="headerlink" title="9. vuex"></a>9. vuex</h2><pre><code>在实际业务中，经常会有跨组件共享数据的需求，如果项目不复杂，使用bus就能简单的解决问题，但是使用bus在数据的管理、维护、架构设计上还只是一个简单的组件，在大型单页应用，多然开发的项目中，Vuex能更加优雅和高效的完成状态管理。![招不出](../pictures/vuex.png)</code></pre>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;平时在使用Vue框架的业务开发中，组件不仅仅要把模板的内容进行复用，更重要的是组件之间要进行通信。
组件之间通信分为三种：父-子；子-父；跨级组件通信。下面，就组件间如何通信做一些总结。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>el-tree复选框父子节点</title>
    <link href="http://example.com/2020/08/19/el-tree%E5%A4%8D%E9%80%89%E6%A1%86%E7%88%B6%E5%AD%90%E8%8A%82%E7%82%B9/"/>
    <id>http://example.com/2020/08/19/el-tree%E5%A4%8D%E9%80%89%E6%A1%86%E7%88%B6%E5%AD%90%E8%8A%82%E7%82%B9/</id>
    <published>2020-08-19T12:13:44.000Z</published>
    <updated>2020-08-19T12:18:42.425Z</updated>
    
    <content type="html"><![CDATA[<pre><code>element ui的el-tree多选树(复选框)父子节点关联不关联的问题，选中当前节点，他的子节点和父节点是否被选中.如何实际中Tree比较大，用ztree，vue-giant-tree就表现的很强悍了。</code></pre><span id="more"></span><h2 id="属性check-strictly"><a href="#属性check-strictly" class="headerlink" title="属性check-strictly"></a>属性check-strictly</h2><pre><code>官方文档提供属性check-strictly，在显示复选框的情况下，是否严格的遵循父子不互相关联的做法，默认为 false。</code></pre><h3 id="设置true，严格的遵循父子不互相关联。"><a href="#设置true，严格的遵循父子不互相关联。" class="headerlink" title="设置true，严格的遵循父子不互相关联。"></a>设置true，严格的遵循父子不互相关联。</h3><pre><code>1、当你通过函数设置勾选节点的时候，严格通过设置勾选的list中有无此节点来断定是否勾选。2、当你点击勾选复选框时候，无论点击的哪个节点只会改变当前节点的勾选状态，不存在半选状态。</code></pre><h3 id="系统的角色菜单控制的问题"><a href="#系统的角色菜单控制的问题" class="headerlink" title="系统的角色菜单控制的问题"></a>系统的角色菜单控制的问题</h3><pre><code>问题来了，在系统的角色菜单控制的时候，需要满足以下条件：1、当点击勾选复选框时候，若点击父节点，其下子节点全部统一跟随父节点变化。2、当点击勾选复选框时候，若点击子节点，子节点部分勾选时父节点处于半选状态，子节点全部勾选时父节点选中，子节点全部不勾选时父节点未选中。</code></pre><h2 id="需求问题"><a href="#需求问题" class="headerlink" title="需求问题"></a>需求问题</h2><pre><code>当属性check-strictly设置为true的时候，父子节点之间不关联。但大多数需求可能需要在选中父节点的时候，他的所有子节点都要被选中。当选中当前节点的时候，他的所有父节点和子节点都要被选中。</code></pre><h3 id="check-strictly-false，行不通"><a href="#check-strictly-false，行不通" class="headerlink" title="check-strictly=false，行不通"></a>check-strictly=false，行不通</h3><pre><code>按照需要满足的条件，明显靠近将check-strictly设置为false，于是从check-strictly=false父子互相关联的基础入手，需要解决的问题就是：将尚未全部勾选的子节点对应的父节点改为半勾选状态，但是查找文档良久无果。只有getHalfCheckedKeys和getHalfCheckedNodes，并没有设置成半勾选。</code></pre><h3 id="check-strictly-true，试一试"><a href="#check-strictly-true，试一试" class="headerlink" title="check-strictly=true，试一试"></a>check-strictly=true，试一试</h3><pre><code>只能试一下将check-strictly设置为true，从check-strictly=true严格的遵循父子不互相关联入手，需要解决的问题就是：1、当点击勾选复选框时候，若点击父节点，其下子节点全部统一跟随父节点变化。2、当点击勾选复选框时候，若点击子节点，子节点部分勾选时父节点处于半选状态，子节点全部勾选时父节点选中，子节点全部不勾选时父节点未选中。而在严格的父子不互相关联时，点击父子节点不会出现半选状态，也无法通过函数设置半选状态，无奈简化解决问题：1、当点击勾选复选框时候，若状态为 选中 ：1.1、其所有 父节点 （父节点、父节点的父节点以此类推）全部统一跟随当前节点变化为 选中 。1.2、其下 子节点 全部统一跟随父节点变化为 选中 。2、当点击勾选复选框时候，若状态为 未选中 ，其下 子节点 全部统一跟随父节点变化为 未选中 。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;el-tree</span><br><span class="line">     :data=<span class="string">&quot;resourceTree&quot;</span></span><br><span class="line">     ref=<span class="string">&quot;resourceTree&quot;</span></span><br><span class="line">     show-checkbox</span><br><span class="line">     node-key=<span class="string">&quot;id&quot;</span></span><br><span class="line">     :check-strictly=<span class="string">&quot;true&quot;</span> </span><br><span class="line">     v-loading=<span class="string">&quot;dialogLoading&quot;</span></span><br><span class="line">     @check=<span class="string">&quot;nodeClick&quot;</span></span><br><span class="line">     :props=<span class="string">&quot;defaultProps&quot;</span>&gt;</span><br><span class="line">   &lt;/el-tree&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nodeClick (currentObj, treeStatus) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(currentObj)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;=========&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(treeStatus)</span><br><span class="line">  <span class="comment">// 用于：父子节点严格互不关联时，父节点勾选变化时通知子节点同步变化，实现单向关联。</span></span><br><span class="line">  <span class="keyword">let</span> selected = treeStatus.checkedKeys.indexOf(currentObj.id) <span class="comment">// -1未选中,&gt;=0为选中</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(selected)</span><br><span class="line">  <span class="comment">// 选中</span></span><br><span class="line">  <span class="keyword">if</span> (selected !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 子节点只要被选中父节点就被选中(需要选中父节点时候调用此方法)</span></span><br><span class="line">      <span class="built_in">this</span>.selectedParent(currentObj)</span><br><span class="line">      <span class="comment">// 统一处理子节点为相同的勾选状态</span></span><br><span class="line">      <span class="built_in">this</span>.uniteChildSame(currentObj, <span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 未选中 处理子节点全部未选中</span></span><br><span class="line">      <span class="keyword">if</span> (currentObj.children.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.uniteChildSame(currentObj, <span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一处理子节点为相同的勾选状态，当选中父节点的时候，把其所有子节点也选中</span></span><br><span class="line">uniteChildSame (treeList, isSelected) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;aaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(treeList);</span><br><span class="line">  <span class="built_in">this</span>.$refs.resourceTree.setChecked(treeList.id, isSelected)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; treeList.children.length; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>.uniteChildSame(treeList.children[i], isSelected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 统选中当前节点，他的所有父节点都被选中,没有半选状态</span></span><br><span class="line">selectedParent (currentObj) &#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = <span class="built_in">this</span>.$refs.resourceTree.getNode(currentObj)</span><br><span class="line">  <span class="keyword">if</span> (currentNode.parent.key !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$refs.resourceTree.setChecked(currentNode.parent, <span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">this</span>.selectedParent(currentNode.parent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;element ui的el-tree多选树(复选框)父子节点关联不关联的问题，选中当前节点，他的子节点和父节点是否被选中.
如何实际中Tree比较大，用ztree，vue-giant-tree就表现的很强悍了。
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="zTree" scheme="http://example.com/tags/zTree/"/>
    
  </entry>
  
  <entry>
    <title>数据响应式原理剖析</title>
    <link href="http://example.com/2020/07/25/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://example.com/2020/07/25/%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/</id>
    <published>2020-07-25T04:58:48.000Z</published>
    <updated>2020-08-19T12:28:28.375Z</updated>
    
    <content type="html"><![CDATA[<pre><code>数据响应式原理proxy，数据的渲染以及双向绑定的原理</code></pre><span id="more"></span><h2 id="Proxy代理与数据劫持"><a href="#Proxy代理与数据劫持" class="headerlink" title="Proxy代理与数据劫持"></a>Proxy代理与数据劫持</h2><pre><code>1. Handler.set()2. Handler.get()3. Handler...</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">age: <span class="string">&#x27;30&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//box.innerHTML = data.age;</span></span><br><span class="line"><span class="comment">//data.age = 21;</span></span><br><span class="line"><span class="comment">//console.log(data);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,prop,newValue</span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;set...&#x27;</span>, target,prop,newValue);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;get...&#x27;</span>, target,prop);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.get(...arguments);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.name);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vue中的数据响应式实现"><a href="#vue中的数据响应式实现" class="headerlink" title="vue中的数据响应式实现"></a>vue中的数据响应式实现</h2><pre><code>1. 获取子元素2. 匹配内容规则3. 修改规则</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">&#123;&#123; name &#125;&#125;</span><br><span class="line">&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;input v-model=<span class="string">&quot;test&quot;</span>&gt;</span><br><span class="line">&#123;&#123; test &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">data: &#123;</span><br><span class="line">name: <span class="string">&#x27;james&#x27;</span>,</span><br><span class="line">message: <span class="string">&#x27;测试数据&#x27;</span>,</span><br><span class="line">test: <span class="string">&#x27;双绑数据&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//vm._data.name=&#x27;lebron&#x27;;</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新建一个js文件，在html中引入，js文件如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vue</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">option</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.option = option;</span><br><span class="line"><span class="built_in">this</span>._data = <span class="built_in">this</span>.option.data;</span><br><span class="line"><span class="built_in">this</span>.el = <span class="built_in">document</span>.querySelector(<span class="built_in">this</span>.option.el);</span><br><span class="line"><span class="built_in">this</span>.compileNode(<span class="built_in">this</span>.el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">compileNode</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line"><span class="keyword">let</span> child = el.childNodes;</span><br><span class="line">[...child].forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(node.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;这是一个文本节点&#x27;);</span></span><br><span class="line"><span class="keyword">let</span> text = node.textContent;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;\s*([^\s\&#123;\&#125;]+)\s*\&#125;\&#125;/g</span>;</span><br><span class="line"><span class="keyword">if</span>(reg.test(text)) &#123;</span><br><span class="line"><span class="keyword">let</span> $<span class="number">1</span> = <span class="built_in">RegExp</span>.$1;</span><br><span class="line"><span class="built_in">this</span>._data[$<span class="number">1</span>] &amp;&amp; (node.textContent = text.replace(reg, <span class="built_in">this</span>._data[$<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.compileNode(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vue中双向绑定实现"><a href="#vue中双向绑定实现" class="headerlink" title="vue中双向绑定实现"></a>vue中双向绑定实现</h2><pre><code>1. 监控数据变化2. 通过自定义事件通知3. 修改规则</code></pre><p>接下来继续写js文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> <span class="keyword">extends</span> <span class="title">EventTarget</span></span>&#123;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">option</span>)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.option = option;</span><br><span class="line"><span class="built_in">this</span>._data = <span class="built_in">this</span>.option.data;</span><br><span class="line"><span class="built_in">this</span>.el = <span class="built_in">document</span>.querySelector(<span class="built_in">this</span>.option.el);</span><br><span class="line"><span class="built_in">this</span>.observe(<span class="built_in">this</span>._data);</span><br><span class="line"><span class="built_in">this</span>.compileNode(<span class="built_in">this</span>.el);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">observe</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line"><span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line"><span class="built_in">this</span>._data = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line"><span class="function"><span class="title">set</span>(<span class="params">target,prop,newValue</span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(newValue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> event = <span class="keyword">new</span> CustomEvent(prop, &#123;</span><br><span class="line">detail: newValue</span><br><span class="line">&#125;);</span><br><span class="line">_this.dispatchEvent(event);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Reflect</span>.set(...arguments);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">compileNode</span>(<span class="params">el</span>)</span> &#123;</span><br><span class="line"><span class="keyword">let</span> child = el.childNodes;</span><br><span class="line">[...child].forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(node.nodeType === <span class="number">3</span>) &#123;</span><br><span class="line"><span class="comment">//console.log(&#x27;这是一个文本节点&#x27;);</span></span><br><span class="line"><span class="keyword">let</span> text = node.textContent;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;\s*([^\s\&#123;\&#125;]+)\s*\&#125;\&#125;/g</span>;</span><br><span class="line"><span class="keyword">if</span>(reg.test(text)) &#123;</span><br><span class="line"><span class="keyword">let</span> $<span class="number">1</span> = <span class="built_in">RegExp</span>.$1;</span><br><span class="line"><span class="built_in">this</span>._data[$<span class="number">1</span>] &amp;&amp; (node.textContent = text.replace(reg, <span class="built_in">this</span>._data[$<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.addEventListener($<span class="number">1</span>, <span class="function"><span class="params">e</span>=&gt;</span> &#123;</span><br><span class="line">node.textContent = text.replace(reg, e.detail);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> attr = node.attributes;</span><br><span class="line"><span class="built_in">console</span>.log(attr);</span><br><span class="line"><span class="keyword">if</span>(attr.hasOwnProperty(<span class="string">&#x27;v-model&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">let</span> keyName = attr[<span class="string">&#x27;v-model&#x27;</span>].nodeValue;</span><br><span class="line"><span class="built_in">console</span>.log(keyName);</span><br><span class="line">node.value = <span class="built_in">this</span>._data[keyName];</span><br><span class="line">node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">e</span>=&gt;</span> &#123;</span><br><span class="line"><span class="built_in">this</span>._data[keyName] = node.value;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.compileNode(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;数据响应式原理proxy，数据的渲染以及双向绑定的原理
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="js, vue" scheme="http://example.com/tags/js-vue/"/>
    
  </entry>
  
  <entry>
    <title>this指向详解</title>
    <link href="http://example.com/2020/07/21/this%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2020/07/21/this%E6%8C%87%E5%90%91%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-07-21T14:01:40.000Z</published>
    <updated>2020-08-19T12:28:55.827Z</updated>
    
    <content type="html"><![CDATA[<pre><code>变化莫测的this指向</code></pre><span id="more"></span><h2 id="function中的this在不同环境下的指向"><a href="#function中的this在不同环境下的指向" class="headerlink" title="function中的this在不同环境下的指向"></a>function中的this在不同环境下的指向</h2><h3 id="事件调用环境中，"><a href="#事件调用环境中，" class="headerlink" title="事件调用环境中，"></a>事件调用环境中，</h3><pre><code>       谁触发事件，函数里面的this指向的就是谁</code></pre><h3 id="全局环境下，"><a href="#全局环境下，" class="headerlink" title="全局环境下，"></a>全局环境下，</h3><pre><code>       浏览器环境指的的window，node环境中是module.exports</code></pre><h3 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h3><pre><code>1 this最终指向的是调用它的对象，和它的声明没有关系。    普通函数直接调用与window调用    对象中的函数直接调用与window调用2 函数被多层对象所包含，如果函数被最外层对象调用，this指向的也只是它上一级的对象。    多层对象中的函数的this指向。    对象中的函数被赋值给另一个变量</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">10</span>;</span><br><span class="line">b: &#123;</span><br><span class="line">fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> abc = obj.b.fn;</span><br><span class="line"><span class="built_in">window</span>.obj.b.fn(); <span class="comment">//b</span></span><br><span class="line">abc(); <span class="comment">//window，调用它的是window，与它的声明没有关系</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>3 构造函数中的this指向的是实例对象。    构造函数中的this指向。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.num = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn.num = <span class="number">20</span>;</span><br><span class="line">fn.prototype.num = <span class="number">30</span>;</span><br><span class="line">fn.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> prototype = fn.prototype;</span><br><span class="line"><span class="keyword">var</span> method = prototype.method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> fn().method(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">prototype.method(); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">method(); <span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>    new运算符的作用        a. 调用函数        b. 自动创建一个对象        c. 把创建出来的对象和this进行绑定        d. 如果构造函数没有返回值，隐式返回this对象4 如果构造函数中有return，如果return的值是对象，this指向返回的对象，如果不是对象，  则this指向保持原来的规则，在这里，null比较特殊，null也是对象，但还是保持原来的规则。</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fn();</span><br><span class="line"><span class="built_in">console</span>.log(obj.num);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数中的this指向的特殊性"><a href="#箭头函数中的this指向的特殊性" class="headerlink" title="箭头函数中的this指向的特殊性"></a>箭头函数中的this指向的特殊性</h2><pre><code>箭头函数本身是没有this和arguments的，箭头函数的this指向在定义的时候就决定了，在箭头函数中引用this实际上调用的是定义的上一层作用域的this。这里需要注意的是上一层作用域，因对对象是不能形成独立的作用域的。总之来说箭头函数修复了this指向，指向上下文。</code></pre><h2 id="如何改变this指向"><a href="#如何改变this指向" class="headerlink" title="如何改变this指向"></a>如何改变this指向</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> box = &#123;</span><br><span class="line">color: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a,b,c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn.bind(box)(); <span class="comment">//&#123;color: &quot;blue&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>call(this,a,b,c);apply(this, [a,b,c]);bind(this,a,b,c)(); //bind会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。console.log(this);这样来扩充函数赖以运行的作用域</code></pre>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;变化莫测的this指向
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>vue源码解析</title>
    <link href="http://example.com/2019/10/15/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2019/10/15/vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2019-10-15T14:37:08.000Z</published>
    <updated>2020-08-19T12:29:21.844Z</updated>
    
    <content type="html"><![CDATA[<pre><code>深入理解vue底层原理,手写vue核心部分实现,vue工作机制,Vue响应式的原理,依赖收集与追踪,编译compile</code></pre><span id="more"></span><h2 id="vue工作机制"><a href="#vue工作机制" class="headerlink" title="vue工作机制"></a>vue工作机制</h2><p><img src="E:\hexo\source\_posts\pictures/vue1.png" alt="招不出"></p><h2 id="Vue响应式的原理defineProperty"><a href="#Vue响应式的原理defineProperty" class="headerlink" title="Vue响应式的原理defineProperty"></a>Vue响应式的原理defineProperty</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KVue</span> </span>&#123;</span><br><span class="line">constructor(options) &#123;</span><br><span class="line"><span class="keyword">this</span>._data = options.data;</span><br><span class="line"><span class="keyword">this</span>.observer(<span class="keyword">this</span>._data);</span><br><span class="line">&#125;</span><br><span class="line">observer(value) &#123;</span><br><span class="line"><span class="keyword">if</span> (!value || typeof value !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object.keys(value).forEach(key =&gt; &#123;</span><br><span class="line"><span class="keyword">this</span>.defineReactive(value, key, value[key]);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">defineReactive(obj, key, val) &#123;</span><br><span class="line">Object.defineProperty(obj, key, &#123;</span><br><span class="line">enumerable: <span class="keyword">true</span> <span class="comment">/* 属性可枚举 */</span>,</span><br><span class="line">configurable: <span class="keyword">true</span> <span class="comment">/* 属性可被修改或删除 */</span>,</span><br><span class="line">get() &#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;,</span><br><span class="line">set(newVal) &#123;</span><br><span class="line"><span class="keyword">if</span> (newVal === val) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">this</span>.cb(newVal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">cb(val) &#123;</span><br><span class="line">console.log(<span class="string">&quot;更新数据了&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let o = <span class="keyword">new</span> KVue(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">test: <span class="string">&quot;I am test.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">o._data.test = <span class="string">&quot;hello,kaikeba&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="依赖收集与追踪"><a href="#依赖收集与追踪" class="headerlink" title="依赖收集与追踪"></a>依赖收集与追踪</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">template:</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;text2&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;,</span><br><span class="line">data: &#123;</span><br><span class="line">text1: <span class="string">&#x27;name1&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line"><span class="keyword">this</span>.text1=<span class="string">&quot;刘思涵&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>text1被修改，所以视图更新，但是text2视图没有用到，所以不需要更新，如何实现呢，就需要用到依赖收集了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖收集</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">constructor () &#123;</span><br><span class="line"><span class="comment">//存放所有的依赖</span></span><br><span class="line"><span class="keyword">this</span>.deps =[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在deps中添加一个监听器对象</span></span><br><span class="line">addDep(dep) &#123;</span><br><span class="line"><span class="keyword">this</span>.deps.push(dep)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知所有监听器去更新视图</span></span><br><span class="line">notify() &#123;</span><br><span class="line"><span class="keyword">this</span>.deps.forEach((dep)=&gt; &#123;</span><br><span class="line">dep.update()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">watcher</span> </span>&#123;</span><br><span class="line">constructor () &#123;</span><br><span class="line"><span class="comment">//在new一个监听器对象时将该对象赋值给Dep.target,在get中会用到</span></span><br><span class="line">Dep.target = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新视图的方法</span></span><br><span class="line">update () &#123;</span><br><span class="line">console.log(<span class="string">&quot;视图更新了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="E:\hexo\source\_posts\pictures/vue2.png" alt="刘思涵"></p><p>我们在增加了一个 Dep 类的对象，用来收集 Watcher 对象。读数据的时候，会触发 reactiveGetter 函数把当前的<br>Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。<br>写数据的时候，则会触发 reactiveSetter 方法，通知Dep 类调用 notify 来触发所有 watcher 对象的update 方法更 新对应视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">option</span>)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>._data = option.data</span><br><span class="line"><span class="built_in">this</span>.observe(<span class="built_in">this</span>._data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象</span></span><br><span class="line"><span class="keyword">new</span> Watcher();</span><br><span class="line"><span class="comment">//  在这里模拟render的过程，为了触发test属性的get函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;模拟render, 触发test的getter&#x27;</span>, <span class="built_in">this</span>._data.test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span> &#123;</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">enumerable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">true</span>,</span><br><span class="line">get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//  将Dep.target（即当前的Watcher对象存入Dep的deps中）</span></span><br><span class="line">dep.addDep(Dep.target)</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;,</span><br><span class="line">set: funciton <span class="function"><span class="title">reactiveSetter</span>(<span class="params">newval</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(newval === val)  <span class="keyword">return</span></span><br><span class="line"><span class="comment">//  在set的时候触发dep的notify来通知所有的Watcher对象更新视图</span></span><br><span class="line">dep.notify()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译compile"><a href="#编译compile" class="headerlink" title="编译compile"></a>编译compile</h2><p><img src="E:\hexo\source\_posts\pictures/vue3.png" alt="招不出"></p><h2 id="compile-js"><a href="#compile-js" class="headerlink" title="compile.js"></a>compile.js</h2><h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><h2 id="依赖收集Dep"><a href="#依赖收集Dep" class="headerlink" title="依赖收集Dep"></a>依赖收集Dep</h2><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;深入理解vue底层原理,手写vue核心部分实现,vue工作机制,Vue响应式的原理,依赖收集与追踪,编译compile
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="vuejs" scheme="http://example.com/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>ES6特性总结学习</title>
    <link href="http://example.com/2019/09/30/ES6%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2019/09/30/ES6%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-09-29T16:01:27.000Z</published>
    <updated>2020-08-19T12:29:59.483Z</updated>
    
    <content type="html"><![CDATA[<p>  在React中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过props）,<br>  所以，两个非父子组件之间通信就相对麻烦，redux的出现就是为了解决state里面的数据问题</p><span id="more"></span><p>1.变量<br>  var     重复声明、函数级<br>  let     不能重复声明、块级作用域、变量<br>  const   不能重复声明、块级作用域、常量</p><p>2.箭头函数<br>  a.方便<br>    i.如果只有一个参数，()可以省<br>    ii.如果只有一个return，{}也可以省<br>  b.修正this<br>    this相对正常点，this指向的是上下文作用域，和普通的函数是不一样的</p><p>3.参数扩展…arg<br>  收集<br>  扩展</p><p>  默认参数<br>    function show(a, b=5){</p><pre><code>&#125;</code></pre><p>4.数组方法<br>  map       映射<br>  reduce    汇总：一堆-&gt;一个<br>  filter    过滤：一堆-&gt;剩下的<br>  forEach   循环</p><p>5.字符串<br>  startsWith/endsWith<br>  字符串模板：<code>$&#123;a&#125;xxx$&#123;b&#125;</code></p><p>6.Promise<br>  封装异步操作</p><p>  Promise.all([]);</p><p>7.generator</p><p>  function *show(){<br>    yield<br>  }</p><p>8.JSON<br>  JSON.stringify({a:12,b:5})  =&gt;  ‘{“a”:12,”b”:5}’<br>  JSON.parse(‘{“a”:12,”b”:5}’)=&gt;  {a:12,b:5}</p><p>9.解构赋值<br>  let [a,b,c]=[12,5,8];</p><p>  左右结构一样<br>  右边是个合法的东西<br>  声明、赋值一次完成</p><p>10.面向对象<br>  class Test{<br>    constructor(){<br>      this.xxx=<br>    }</p><pre><code>方法1()&#123;&#125;方法2()&#123;&#125;</code></pre><p>  }</p><p>  class Cls2 extends Cls1{<br>    constructor(){<br>      super();<br>    }<br>  }</p><p>11 map和set的区别</p><p>   set结构类似于数组结构，它的成员都是不重复的值</p><p>   map结构类似于哈希结构，是键值对集合，关键区别在于map结构的值不是它的键，它的键和值是分开的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;  在React中，数据在组件中是单向流动的，数据从一个方向父组件流向子组件（通过props）,&lt;br&gt;  所以，两个非父子组件之间通信就相对麻烦，redux的出现就是为了解决state里面的数据问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://example.com/2019/09/21/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2019/09/21/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2019-09-20T16:30:08.000Z</published>
    <updated>2019-09-20T17:05:24.364Z</updated>
    
    <content type="html"><![CDATA[<p>求一个字符串内的最大回文子串及其长度，这是一道残酷的笔试题</p><span id="more"></span><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>从字符串第一个字符开始，然后看它的左边和右边是否相等，当然第一个字符，回文数就是1。</p><p>然后第二个字符作为中心，它的左边，第一个字符，它的右边，第三个字符，看这两个字符是否相等，若相等，回文长度就是</p><p> 3=2*1+2了，继续往左的话就没有字符了退出本次循环。</p><p>紧接着中心字符变成第三个字符，再来看看以第三个字符为中心是不是回文的，如果是，则更新回文。</p><p>这里用了两个循环嵌套的，第一个循环用来从头到尾遍历字符串，把每个字符串作为中心元素，然后嵌套循环里看以他为中心是否是回文。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>], s[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> n,m=<span class="number">0</span>,max=<span class="number">0</span>,x,y;</span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(s), <span class="built_in">stdin</span>);</span><br><span class="line">    n=<span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[m]=i;</span><br><span class="line">        s[m++]=<span class="built_in">toupper</span>(buf[i]); <span class="comment">//动态规划</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">// i看成是中心元素，然后i-j是左边，i+j是右边元素，比较这两个元素是否相等  </span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;i-j&gt;=<span class="number">0</span>&amp;&amp;i+j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i-j]!=s[i+j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(j*<span class="number">2</span>+<span class="number">1</span>&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//如果J*2+1的值大于最大记录的回文长度，更新最大记录</span></span><br><span class="line">                max = j*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                x=p[i-j];</span><br><span class="line">                y=p[i+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;i-j&gt;=<span class="number">0</span>&amp;&amp;i+j+<span class="number">1</span>&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 同理在偶数长度时，回文长度为2*j+2  </span></span><br><span class="line">            <span class="keyword">if</span>(s[i-j]!=s[i+j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(j*<span class="number">2</span>+<span class="number">2</span>&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = j*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">                x=p[i-j];</span><br><span class="line">                y=p[i+j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=x;i&lt;=y;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="解法二，动态规划"><a href="#解法二，动态规划" class="headerlink" title="解法二，动态规划"></a>解法二，动态规划</h2><p>这方法是网上看到的，不太好理解，不过也有点意思。<br>思想：DP的考虑源于暴力方法，暴力方法是寻找一个字符串的所有子串，需要O(n^2)的开销，然后对于每一个子串需要O(n)的开销来判断是否是回文，故暴力方案为O(n^3)，但是这里有一个问题，就是在暴力的时候有重复判断；</p><p>如果子串X为回文，那么sXs也是回文；如果X不是回文，那么sXs也不是回文；另外，ss也是回文。所以这里使用DP我们可以按照子串长度从小到大的顺序来构建DP状态数组，使用一个二维数组dp[i][j]记录子串[i-j]是否为回文子串，那么我们就有初始化和自底向上的方案了；</p><p>初始化：单字符串和相等的双字符串为回文</p><p>自底向上构造：X[i]==X[j] &amp;&amp; dp[i+1][j-1]==1 则dp[i][j] = 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">string longestPalindromeDP(string s)</span><br><span class="line">&#123;</span><br><span class="line">    int n &#x3D; s.length();</span><br><span class="line">    int longestBegin &#x3D; 0, maxLen &#x3D; 1;</span><br><span class="line">    bool table[1000][1000] &#x3D; &#123;false&#125;;</span><br><span class="line">    for (int i&#x3D;0; i&lt;n; i++)</span><br><span class="line">        table[i][i] &#x3D; true;</span><br><span class="line">    for (int i&#x3D;0; i&lt;n-1; i++) &#123;</span><br><span class="line">        if (s[i] &#x3D;&#x3D; s[i+1]) &#123;</span><br><span class="line">            table[i][i+1] &#x3D; true;</span><br><span class="line">            longestBegin &#x3D; i;</span><br><span class="line">            maxLen &#x3D; 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#x2F;*依次求table[i][i+2]...table[i][i+n-1]等*&#x2F;</span><br><span class="line">    for (int len&#x3D;3; len&lt;&#x3D;n; ++len) &#123;</span><br><span class="line">        for (int i&#x3D;0; i&lt;n-len+1; ++i) &#123;</span><br><span class="line">            int j &#x3D; i + len - 1;</span><br><span class="line">            if (s[i]&#x3D;&#x3D;s[j] &amp;&amp; table[i+1][j-1]) &#123;</span><br><span class="line">                table[i][j] &#x3D; true;</span><br><span class="line">                longestBegin &#x3D; i;</span><br><span class="line">                maxLen &#x3D; len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substr(longestBegin, maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;求一个字符串内的最大回文子串及其长度，这是一道残酷的笔试题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>js基础</title>
    <link href="http://example.com/2019/09/18/js%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2019/09/18/js%E5%9F%BA%E7%A1%80/</id>
    <published>2019-09-18T15:03:15.000Z</published>
    <updated>2019-09-25T15:33:54.483Z</updated>
    
    <content type="html"><![CDATA[<p>面试中需要知道的一点js基础<br><span id="more"></span></p><h2 id="怎样添加、移除、移动、复制、创建和查找节点？"><a href="#怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="怎样添加、移除、移动、复制、创建和查找节点？"></a>怎样添加、移除、移动、复制、创建和查找节点？</h2><h3 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h3><p>createDocumentFragment() //创建一个DOM片段<br>createElement() //创建一个具体的元素<br>createTextNode() //创建一个文本节点</p><h3 id="添加、移除、替换、插入"><a href="#添加、移除、替换、插入" class="headerlink" title="添加、移除、替换、插入"></a>添加、移除、替换、插入</h3><p>appendChild() //添加<br>removeChild() //移除<br>replaceChild() //替换<br>insertBefore() //插入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name属性的值<br>getElementById() //通过元素Id，唯一性</p><h2 id="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。"><a href="#实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。" class="headerlink" title="实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。"></a>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制。</h2><p>  /**</p><ul><li>对象克隆</li><li>支持基本数据类型及对象</li><li><p>递归方法<br>*/</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">typeof</span> obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;undefined&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;string&quot;</span>:</span><br><span class="line">            o = obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;number&quot;</span>:</span><br><span class="line">            o = obj - <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;boolean&quot;</span>:</span><br><span class="line">            o = obj;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;object&quot;</span>: <span class="comment">// object 分为两种情况 对象（Object）或数组（Array）</span></span><br><span class="line">            <span class="keyword">if</span> (obj === <span class="literal">null</span>) &#123;</span><br><span class="line">                o = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;Array&quot;</span>) &#123;</span><br><span class="line">                    o = [];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i  obj.length; i++) &#123;</span><br><span class="line">                        o.push(clone(obj[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    o = &#123;&#125;;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                        o[k] = clone(obj[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            o = obj;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="判断一个字符串出现次数最多的字符，统计这个次数并输出"><a href="#判断一个字符串出现次数最多的字符，统计这个次数并输出" class="headerlink" title="判断一个字符串出现次数最多的字符，统计这个次数并输出"></a>判断一个字符串出现次数最多的字符，统计这个次数并输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function count(str)&#123;</span><br><span class="line">    var max &#x3D; 0; </span><br><span class="line">    var obj &#x3D; &#123;&#125;;</span><br><span class="line">    var maxStr &#x3D; &#39;&#39;;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; str.length; i++)&#123;</span><br><span class="line">        var charAt &#x3D; str.charAt(i);</span><br><span class="line">        if(obj[charAt])&#123;</span><br><span class="line">            obj[charAt]++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            obj[charAt]&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(let i in obj)&#123;</span><br><span class="line">          if(obj[i]&gt;max)&#123;</span><br><span class="line">            max &#x3D; obj[i];</span><br><span class="line">            maxStr &#x3D; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return maxStr +&#39;,&#39;+&#39;出现&#39;+max+&#39;次&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何消除一个数组里面重复的元素？"><a href="#如何消除一个数组里面重复的元素？" class="headerlink" title="如何消除一个数组里面重复的元素？"></a>如何消除一个数组里面重复的元素？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr1 &#x3D;[1,2,2,2,3,3,3,4,5,6],</span><br><span class="line">    arr2 &#x3D; [];</span><br><span class="line">for(var i &#x3D; 0,len &#x3D; arr1.length; i&lt; len; i++)&#123;</span><br><span class="line">    if(arr2.indexOf(arr1[i]) &lt; 0)&#123;</span><br><span class="line">        arr2.push(arr1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.write(arr2); &#x2F;&#x2F; 1,2,3,4,5,6</span><br></pre></td></tr></table></figure><h2 id="想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。"><a href="#想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。" class="headerlink" title="想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。"></a>想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）。</h2><h2 id="在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#在Javascript中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"></a>在Javascript中什么是伪数组？如何将伪数组转化为标准数组？</h2><p>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log()&#123;</span><br><span class="line">      var args &#x3D; Array.prototype.slice.call(arguments);  </span><br><span class="line">   &#x2F;&#x2F;为了使用unshift数组方法，将argument转化为真正的数组</span><br><span class="line">      args.unshift(&#39;(app)&#39;);</span><br><span class="line"> </span><br><span class="line">      console.log.apply(console, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Javascript中callee和caller的作用？"><a href="#Javascript中callee和caller的作用？" class="headerlink" title="Javascript中callee和caller的作用？"></a>Javascript中callee和caller的作用？</h2><p>caller是返回一个对函数的引用，该函数调用了当前函数；</p><p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p><h2 id="请描述一下cookies，sessionStorage和localStorage的区别"><a href="#请描述一下cookies，sessionStorage和localStorage的区别" class="headerlink" title="请描述一下cookies，sessionStorage和localStorage的区别"></a>请描述一下cookies，sessionStorage和localStorage的区别</h2><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p>web storage和cookie的区别</p><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。<br>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><h2 id="手写数组快速排序"><a href="#手写数组快速排序" class="headerlink" title="手写数组快速排序"></a>手写数组快速排序</h2><p>关于快排算法的详细说明，可以参考阮一峰老师的文章快速排序<br>“快速排序”的思想很简单，整个排序过程只需要三步：<br>（1）在数据集之中，选择一个元素作为”基准”（pivot）。<br>（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。<br>（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</p><h2 id="统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。"><a href="#统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。" class="headerlink" title="统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。"></a>统计字符串”aaaabbbccccddfgh”中字母个数或统计最多字母数。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var str &#x3D; &quot;aaaabbbccccddfgh&quot;;</span><br><span class="line">var obj  &#x3D; &#123;&#125;;</span><br><span class="line">for(var i&#x3D;0;istr.length;i++)&#123;</span><br><span class="line">    var v &#x3D; str.charAt(i);</span><br><span class="line">    if(obj[v] &amp; obj[v].value &#x3D;&#x3D; v)&#123;</span><br><span class="line">        obj[v].count &#x3D; ++ obj[v].count;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        obj[v] &#x3D; &#123;&#125;;</span><br><span class="line">        obj[v].count &#x3D; 1;</span><br><span class="line">        obj[v].value &#x3D; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(key in obj)&#123;</span><br><span class="line">    document.write(obj[key].value +&#39;&#x3D;&#39;+obj[key].count+&#39; &#39;); &#x2F;&#x2F; a&#x3D;4  b&#x3D;3  c&#x3D;4  d&#x3D;2  f&#x3D;1  g&#x3D;1  h&#x3D;1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#写一个function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="写一个function，清除字符串前后的空格。（兼容所有浏览器）"></a>写一个function，清除字符串前后的空格。（兼容所有浏览器）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function trim(str) &#123;</span><br><span class="line">    if (str &amp; typeof str &#x3D;&#x3D;&#x3D; &quot;string&quot;) &#123;</span><br><span class="line">        return str.replace(&#x2F;(^s*)|(s*)$&#x2F;g,&quot;&quot;); &#x2F;&#x2F;去除前后空白符</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试中需要知道的一点js基础&lt;br&gt;</summary>
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
</feed>
